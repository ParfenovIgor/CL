/* File generated by the BNF Converter (bnfc 2.9.4). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   ProgramRoot    ********************/
ProgramRoot::ProgramRoot(ListStatement *p1)
{
  liststatement_ = p1;

}

ProgramRoot::ProgramRoot(const ProgramRoot & other)
{
  liststatement_ = other.liststatement_->clone();

}

ProgramRoot &ProgramRoot::operator=(const ProgramRoot & other)
{
  ProgramRoot tmp(other);
  swap(tmp);
  return *this;
}

void ProgramRoot::swap(ProgramRoot & other)
{
  std::swap(liststatement_, other.liststatement_);

}

ProgramRoot::~ProgramRoot()
{
  delete(liststatement_);

}

void ProgramRoot::accept(Visitor *v)
{
  v->visitProgramRoot(this);
}

ProgramRoot *ProgramRoot::clone() const
{
  return new ProgramRoot(*this);
}



/********************   ConstTrue    ********************/
ConstTrue::ConstTrue()
{

}

ConstTrue::ConstTrue(const ConstTrue & other)
{

}

ConstTrue &ConstTrue::operator=(const ConstTrue & other)
{
  ConstTrue tmp(other);
  swap(tmp);
  return *this;
}

void ConstTrue::swap(ConstTrue & other)
{

}

ConstTrue::~ConstTrue()
{

}

void ConstTrue::accept(Visitor *v)
{
  v->visitConstTrue(this);
}

ConstTrue *ConstTrue::clone() const
{
  return new ConstTrue(*this);
}



/********************   ConstFalse    ********************/
ConstFalse::ConstFalse()
{

}

ConstFalse::ConstFalse(const ConstFalse & other)
{

}

ConstFalse &ConstFalse::operator=(const ConstFalse & other)
{
  ConstFalse tmp(other);
  swap(tmp);
  return *this;
}

void ConstFalse::swap(ConstFalse & other)
{

}

ConstFalse::~ConstFalse()
{

}

void ConstFalse::accept(Visitor *v)
{
  v->visitConstFalse(this);
}

ConstFalse *ConstFalse::clone() const
{
  return new ConstFalse(*this);
}



/********************   ConstZero    ********************/
ConstZero::ConstZero()
{

}

ConstZero::ConstZero(const ConstZero & other)
{

}

ConstZero &ConstZero::operator=(const ConstZero & other)
{
  ConstZero tmp(other);
  swap(tmp);
  return *this;
}

void ConstZero::swap(ConstZero & other)
{

}

ConstZero::~ConstZero()
{

}

void ConstZero::accept(Visitor *v)
{
  v->visitConstZero(this);
}

ConstZero *ConstZero::clone() const
{
  return new ConstZero(*this);
}



/********************   If    ********************/
If::If(Expr *p1, Expr *p2, Expr *p3)
{
  expr_1 = p1;
  expr_2 = p2;
  expr_3 = p3;

}

If::If(const If & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();
  expr_3 = other.expr_3->clone();

}

If &If::operator=(const If & other)
{
  If tmp(other);
  swap(tmp);
  return *this;
}

void If::swap(If & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);
  std::swap(expr_3, other.expr_3);

}

If::~If()
{
  delete(expr_1);
  delete(expr_2);
  delete(expr_3);

}

void If::accept(Visitor *v)
{
  v->visitIf(this);
}

If *If::clone() const
{
  return new If(*this);
}



/********************   Succ    ********************/
Succ::Succ(Expr *p1)
{
  expr_ = p1;

}

Succ::Succ(const Succ & other)
{
  expr_ = other.expr_->clone();

}

Succ &Succ::operator=(const Succ & other)
{
  Succ tmp(other);
  swap(tmp);
  return *this;
}

void Succ::swap(Succ & other)
{
  std::swap(expr_, other.expr_);

}

Succ::~Succ()
{
  delete(expr_);

}

void Succ::accept(Visitor *v)
{
  v->visitSucc(this);
}

Succ *Succ::clone() const
{
  return new Succ(*this);
}



/********************   Pred    ********************/
Pred::Pred(Expr *p1)
{
  expr_ = p1;

}

Pred::Pred(const Pred & other)
{
  expr_ = other.expr_->clone();

}

Pred &Pred::operator=(const Pred & other)
{
  Pred tmp(other);
  swap(tmp);
  return *this;
}

void Pred::swap(Pred & other)
{
  std::swap(expr_, other.expr_);

}

Pred::~Pred()
{
  delete(expr_);

}

void Pred::accept(Visitor *v)
{
  v->visitPred(this);
}

Pred *Pred::clone() const
{
  return new Pred(*this);
}



/********************   IsZero    ********************/
IsZero::IsZero(Expr *p1)
{
  expr_ = p1;

}

IsZero::IsZero(const IsZero & other)
{
  expr_ = other.expr_->clone();

}

IsZero &IsZero::operator=(const IsZero & other)
{
  IsZero tmp(other);
  swap(tmp);
  return *this;
}

void IsZero::swap(IsZero & other)
{
  std::swap(expr_, other.expr_);

}

IsZero::~IsZero()
{
  delete(expr_);

}

void IsZero::accept(Visitor *v)
{
  v->visitIsZero(this);
}

IsZero *IsZero::clone() const
{
  return new IsZero(*this);
}



/********************   Var    ********************/
Var::Var(Ident p1)
{
  ident_ = p1;

}

Var::Var(const Var & other)
{
  ident_ = other.ident_;

}

Var &Var::operator=(const Var & other)
{
  Var tmp(other);
  swap(tmp);
  return *this;
}

void Var::swap(Var & other)
{
  std::swap(ident_, other.ident_);

}

Var::~Var()
{

}

void Var::accept(Visitor *v)
{
  v->visitVar(this);
}

Var *Var::clone() const
{
  return new Var(*this);
}



/********************   Abstraction    ********************/
Abstraction::Abstraction(Type *p1, Ident p2, ListStatement *p3, Expr *p4)
{
  type_ = p1;
  ident_ = p2;
  liststatement_ = p3;
  expr_ = p4;

}

Abstraction::Abstraction(const Abstraction & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  liststatement_ = other.liststatement_->clone();
  expr_ = other.expr_->clone();

}

Abstraction &Abstraction::operator=(const Abstraction & other)
{
  Abstraction tmp(other);
  swap(tmp);
  return *this;
}

void Abstraction::swap(Abstraction & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(liststatement_, other.liststatement_);
  std::swap(expr_, other.expr_);

}

Abstraction::~Abstraction()
{
  delete(type_);
  delete(liststatement_);
  delete(expr_);

}

void Abstraction::accept(Visitor *v)
{
  v->visitAbstraction(this);
}

Abstraction *Abstraction::clone() const
{
  return new Abstraction(*this);
}



/********************   MultiAbstraction    ********************/
MultiAbstraction::MultiAbstraction(ListAbstractionField_ *p1, ListStatement *p2, Expr *p3)
{
  listabstractionfield__ = p1;
  liststatement_ = p2;
  expr_ = p3;

}

MultiAbstraction::MultiAbstraction(const MultiAbstraction & other)
{
  listabstractionfield__ = other.listabstractionfield__->clone();
  liststatement_ = other.liststatement_->clone();
  expr_ = other.expr_->clone();

}

MultiAbstraction &MultiAbstraction::operator=(const MultiAbstraction & other)
{
  MultiAbstraction tmp(other);
  swap(tmp);
  return *this;
}

void MultiAbstraction::swap(MultiAbstraction & other)
{
  std::swap(listabstractionfield__, other.listabstractionfield__);
  std::swap(liststatement_, other.liststatement_);
  std::swap(expr_, other.expr_);

}

MultiAbstraction::~MultiAbstraction()
{
  delete(listabstractionfield__);
  delete(liststatement_);
  delete(expr_);

}

void MultiAbstraction::accept(Visitor *v)
{
  v->visitMultiAbstraction(this);
}

MultiAbstraction *MultiAbstraction::clone() const
{
  return new MultiAbstraction(*this);
}



/********************   Application    ********************/
Application::Application(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Application::Application(const Application & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Application &Application::operator=(const Application & other)
{
  Application tmp(other);
  swap(tmp);
  return *this;
}

void Application::swap(Application & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Application::~Application()
{
  delete(expr_1);
  delete(expr_2);

}

void Application::accept(Visitor *v)
{
  v->visitApplication(this);
}

Application *Application::clone() const
{
  return new Application(*this);
}



/********************   TypeAbstraction    ********************/
TypeAbstraction::TypeAbstraction(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

TypeAbstraction::TypeAbstraction(const TypeAbstraction & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

TypeAbstraction &TypeAbstraction::operator=(const TypeAbstraction & other)
{
  TypeAbstraction tmp(other);
  swap(tmp);
  return *this;
}

void TypeAbstraction::swap(TypeAbstraction & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

TypeAbstraction::~TypeAbstraction()
{
  delete(expr_);

}

void TypeAbstraction::accept(Visitor *v)
{
  v->visitTypeAbstraction(this);
}

TypeAbstraction *TypeAbstraction::clone() const
{
  return new TypeAbstraction(*this);
}



/********************   TypeApplication    ********************/
TypeApplication::TypeApplication(Expr *p1, Type *p2)
{
  expr_ = p1;
  type_ = p2;

}

TypeApplication::TypeApplication(const TypeApplication & other)
{
  expr_ = other.expr_->clone();
  type_ = other.type_->clone();

}

TypeApplication &TypeApplication::operator=(const TypeApplication & other)
{
  TypeApplication tmp(other);
  swap(tmp);
  return *this;
}

void TypeApplication::swap(TypeApplication & other)
{
  std::swap(expr_, other.expr_);
  std::swap(type_, other.type_);

}

TypeApplication::~TypeApplication()
{
  delete(expr_);
  delete(type_);

}

void TypeApplication::accept(Visitor *v)
{
  v->visitTypeApplication(this);
}

TypeApplication *TypeApplication::clone() const
{
  return new TypeApplication(*this);
}



/********************   Fix    ********************/
Fix::Fix(Expr *p1)
{
  expr_ = p1;

}

Fix::Fix(const Fix & other)
{
  expr_ = other.expr_->clone();

}

Fix &Fix::operator=(const Fix & other)
{
  Fix tmp(other);
  swap(tmp);
  return *this;
}

void Fix::swap(Fix & other)
{
  std::swap(expr_, other.expr_);

}

Fix::~Fix()
{
  delete(expr_);

}

void Fix::accept(Visitor *v)
{
  v->visitFix(this);
}

Fix *Fix::clone() const
{
  return new Fix(*this);
}



/********************   Where    ********************/
Where::Where(Expr *p1, Type *p2, Ident p3, Expr *p4)
{
  expr_1 = p1;
  type_ = p2;
  ident_ = p3;
  expr_2 = p4;

}

Where::Where(const Where & other)
{
  expr_1 = other.expr_1->clone();
  type_ = other.type_->clone();
  ident_ = other.ident_;
  expr_2 = other.expr_2->clone();

}

Where &Where::operator=(const Where & other)
{
  Where tmp(other);
  swap(tmp);
  return *this;
}

void Where::swap(Where & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(expr_2, other.expr_2);

}

Where::~Where()
{
  delete(expr_1);
  delete(type_);
  delete(expr_2);

}

void Where::accept(Visitor *v)
{
  v->visitWhere(this);
}

Where *Where::clone() const
{
  return new Where(*this);
}



/********************   MultiWhere    ********************/
MultiWhere::MultiWhere(Expr *p1, ListWhereField_ *p2)
{
  expr_ = p1;
  listwherefield__ = p2;

}

MultiWhere::MultiWhere(const MultiWhere & other)
{
  expr_ = other.expr_->clone();
  listwherefield__ = other.listwherefield__->clone();

}

MultiWhere &MultiWhere::operator=(const MultiWhere & other)
{
  MultiWhere tmp(other);
  swap(tmp);
  return *this;
}

void MultiWhere::swap(MultiWhere & other)
{
  std::swap(expr_, other.expr_);
  std::swap(listwherefield__, other.listwherefield__);

}

MultiWhere::~MultiWhere()
{
  delete(expr_);
  delete(listwherefield__);

}

void MultiWhere::accept(Visitor *v)
{
  v->visitMultiWhere(this);
}

MultiWhere *MultiWhere::clone() const
{
  return new MultiWhere(*this);
}



/********************   Reference    ********************/
Reference::Reference(Expr *p1)
{
  expr_ = p1;

}

Reference::Reference(const Reference & other)
{
  expr_ = other.expr_->clone();

}

Reference &Reference::operator=(const Reference & other)
{
  Reference tmp(other);
  swap(tmp);
  return *this;
}

void Reference::swap(Reference & other)
{
  std::swap(expr_, other.expr_);

}

Reference::~Reference()
{
  delete(expr_);

}

void Reference::accept(Visitor *v)
{
  v->visitReference(this);
}

Reference *Reference::clone() const
{
  return new Reference(*this);
}



/********************   Dereference    ********************/
Dereference::Dereference(Expr *p1)
{
  expr_ = p1;

}

Dereference::Dereference(const Dereference & other)
{
  expr_ = other.expr_->clone();

}

Dereference &Dereference::operator=(const Dereference & other)
{
  Dereference tmp(other);
  swap(tmp);
  return *this;
}

void Dereference::swap(Dereference & other)
{
  std::swap(expr_, other.expr_);

}

Dereference::~Dereference()
{
  delete(expr_);

}

void Dereference::accept(Visitor *v)
{
  v->visitDereference(this);
}

Dereference *Dereference::clone() const
{
  return new Dereference(*this);
}



/********************   Tuple    ********************/
Tuple::Tuple(ListExpr *p1)
{
  listexpr_ = p1;

}

Tuple::Tuple(const Tuple & other)
{
  listexpr_ = other.listexpr_->clone();

}

Tuple &Tuple::operator=(const Tuple & other)
{
  Tuple tmp(other);
  swap(tmp);
  return *this;
}

void Tuple::swap(Tuple & other)
{
  std::swap(listexpr_, other.listexpr_);

}

Tuple::~Tuple()
{
  delete(listexpr_);

}

void Tuple::accept(Visitor *v)
{
  v->visitTuple(this);
}

Tuple *Tuple::clone() const
{
  return new Tuple(*this);
}



/********************   TupleGet    ********************/
TupleGet::TupleGet(Expr *p1, Integer p2)
{
  expr_ = p1;
  integer_ = p2;

}

TupleGet::TupleGet(const TupleGet & other)
{
  expr_ = other.expr_->clone();
  integer_ = other.integer_;

}

TupleGet &TupleGet::operator=(const TupleGet & other)
{
  TupleGet tmp(other);
  swap(tmp);
  return *this;
}

void TupleGet::swap(TupleGet & other)
{
  std::swap(expr_, other.expr_);
  std::swap(integer_, other.integer_);

}

TupleGet::~TupleGet()
{
  delete(expr_);

}

void TupleGet::accept(Visitor *v)
{
  v->visitTupleGet(this);
}

TupleGet *TupleGet::clone() const
{
  return new TupleGet(*this);
}



/********************   Record    ********************/
Record::Record(ListRecordField_ *p1)
{
  listrecordfield__ = p1;

}

Record::Record(const Record & other)
{
  listrecordfield__ = other.listrecordfield__->clone();

}

Record &Record::operator=(const Record & other)
{
  Record tmp(other);
  swap(tmp);
  return *this;
}

void Record::swap(Record & other)
{
  std::swap(listrecordfield__, other.listrecordfield__);

}

Record::~Record()
{
  delete(listrecordfield__);

}

void Record::accept(Visitor *v)
{
  v->visitRecord(this);
}

Record *Record::clone() const
{
  return new Record(*this);
}



/********************   RecordGet    ********************/
RecordGet::RecordGet(Expr *p1, Ident p2)
{
  expr_ = p1;
  ident_ = p2;

}

RecordGet::RecordGet(const RecordGet & other)
{
  expr_ = other.expr_->clone();
  ident_ = other.ident_;

}

RecordGet &RecordGet::operator=(const RecordGet & other)
{
  RecordGet tmp(other);
  swap(tmp);
  return *this;
}

void RecordGet::swap(RecordGet & other)
{
  std::swap(expr_, other.expr_);
  std::swap(ident_, other.ident_);

}

RecordGet::~RecordGet()
{
  delete(expr_);

}

void RecordGet::accept(Visitor *v)
{
  v->visitRecordGet(this);
}

RecordGet *RecordGet::clone() const
{
  return new RecordGet(*this);
}



/********************   Variant    ********************/
Variant::Variant(Ident p1, Expr *p2, Type *p3)
{
  ident_ = p1;
  expr_ = p2;
  type_ = p3;

}

Variant::Variant(const Variant & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();
  type_ = other.type_->clone();

}

Variant &Variant::operator=(const Variant & other)
{
  Variant tmp(other);
  swap(tmp);
  return *this;
}

void Variant::swap(Variant & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);
  std::swap(type_, other.type_);

}

Variant::~Variant()
{
  delete(expr_);
  delete(type_);

}

void Variant::accept(Visitor *v)
{
  v->visitVariant(this);
}

Variant *Variant::clone() const
{
  return new Variant(*this);
}



/********************   VariantCase    ********************/
VariantCase::VariantCase(Expr *p1, ListVariantField_ *p2)
{
  expr_ = p1;
  listvariantfield__ = p2;

}

VariantCase::VariantCase(const VariantCase & other)
{
  expr_ = other.expr_->clone();
  listvariantfield__ = other.listvariantfield__->clone();

}

VariantCase &VariantCase::operator=(const VariantCase & other)
{
  VariantCase tmp(other);
  swap(tmp);
  return *this;
}

void VariantCase::swap(VariantCase & other)
{
  std::swap(expr_, other.expr_);
  std::swap(listvariantfield__, other.listvariantfield__);

}

VariantCase::~VariantCase()
{
  delete(expr_);
  delete(listvariantfield__);

}

void VariantCase::accept(Visitor *v)
{
  v->visitVariantCase(this);
}

VariantCase *VariantCase::clone() const
{
  return new VariantCase(*this);
}



/********************   Array    ********************/
Array::Array(ListExpr *p1)
{
  listexpr_ = p1;

}

Array::Array(const Array & other)
{
  listexpr_ = other.listexpr_->clone();

}

Array &Array::operator=(const Array & other)
{
  Array tmp(other);
  swap(tmp);
  return *this;
}

void Array::swap(Array & other)
{
  std::swap(listexpr_, other.listexpr_);

}

Array::~Array()
{
  delete(listexpr_);

}

void Array::accept(Visitor *v)
{
  v->visitArray(this);
}

Array *Array::clone() const
{
  return new Array(*this);
}



/********************   ArrayGet    ********************/
ArrayGet::ArrayGet(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

ArrayGet::ArrayGet(const ArrayGet & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

ArrayGet &ArrayGet::operator=(const ArrayGet & other)
{
  ArrayGet tmp(other);
  swap(tmp);
  return *this;
}

void ArrayGet::swap(ArrayGet & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

ArrayGet::~ArrayGet()
{
  delete(expr_1);
  delete(expr_2);

}

void ArrayGet::accept(Visitor *v)
{
  v->visitArrayGet(this);
}

ArrayGet *ArrayGet::clone() const
{
  return new ArrayGet(*this);
}



/********************   ArrayPush    ********************/
ArrayPush::ArrayPush(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

ArrayPush::ArrayPush(const ArrayPush & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

ArrayPush &ArrayPush::operator=(const ArrayPush & other)
{
  ArrayPush tmp(other);
  swap(tmp);
  return *this;
}

void ArrayPush::swap(ArrayPush & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

ArrayPush::~ArrayPush()
{
  delete(expr_1);
  delete(expr_2);

}

void ArrayPush::accept(Visitor *v)
{
  v->visitArrayPush(this);
}

ArrayPush *ArrayPush::clone() const
{
  return new ArrayPush(*this);
}



/********************   ArrayPop    ********************/
ArrayPop::ArrayPop(Expr *p1)
{
  expr_ = p1;

}

ArrayPop::ArrayPop(const ArrayPop & other)
{
  expr_ = other.expr_->clone();

}

ArrayPop &ArrayPop::operator=(const ArrayPop & other)
{
  ArrayPop tmp(other);
  swap(tmp);
  return *this;
}

void ArrayPop::swap(ArrayPop & other)
{
  std::swap(expr_, other.expr_);

}

ArrayPop::~ArrayPop()
{
  delete(expr_);

}

void ArrayPop::accept(Visitor *v)
{
  v->visitArrayPop(this);
}

ArrayPop *ArrayPop::clone() const
{
  return new ArrayPop(*this);
}



/********************   ArrayLen    ********************/
ArrayLen::ArrayLen(Expr *p1)
{
  expr_ = p1;

}

ArrayLen::ArrayLen(const ArrayLen & other)
{
  expr_ = other.expr_->clone();

}

ArrayLen &ArrayLen::operator=(const ArrayLen & other)
{
  ArrayLen tmp(other);
  swap(tmp);
  return *this;
}

void ArrayLen::swap(ArrayLen & other)
{
  std::swap(expr_, other.expr_);

}

ArrayLen::~ArrayLen()
{
  delete(expr_);

}

void ArrayLen::accept(Visitor *v)
{
  v->visitArrayLen(this);
}

ArrayLen *ArrayLen::clone() const
{
  return new ArrayLen(*this);
}



/********************   ConstInt    ********************/
ConstInt::ConstInt(Integer p1)
{
  integer_ = p1;

}

ConstInt::ConstInt(const ConstInt & other)
{
  integer_ = other.integer_;

}

ConstInt &ConstInt::operator=(const ConstInt & other)
{
  ConstInt tmp(other);
  swap(tmp);
  return *this;
}

void ConstInt::swap(ConstInt & other)
{
  std::swap(integer_, other.integer_);

}

ConstInt::~ConstInt()
{

}

void ConstInt::accept(Visitor *v)
{
  v->visitConstInt(this);
}

ConstInt *ConstInt::clone() const
{
  return new ConstInt(*this);
}



/********************   ToInt    ********************/
ToInt::ToInt(Expr *p1)
{
  expr_ = p1;

}

ToInt::ToInt(const ToInt & other)
{
  expr_ = other.expr_->clone();

}

ToInt &ToInt::operator=(const ToInt & other)
{
  ToInt tmp(other);
  swap(tmp);
  return *this;
}

void ToInt::swap(ToInt & other)
{
  std::swap(expr_, other.expr_);

}

ToInt::~ToInt()
{
  delete(expr_);

}

void ToInt::accept(Visitor *v)
{
  v->visitToInt(this);
}

ToInt *ToInt::clone() const
{
  return new ToInt(*this);
}



/********************   AddInt    ********************/
AddInt::AddInt(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

AddInt::AddInt(const AddInt & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

AddInt &AddInt::operator=(const AddInt & other)
{
  AddInt tmp(other);
  swap(tmp);
  return *this;
}

void AddInt::swap(AddInt & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

AddInt::~AddInt()
{
  delete(expr_1);
  delete(expr_2);

}

void AddInt::accept(Visitor *v)
{
  v->visitAddInt(this);
}

AddInt *AddInt::clone() const
{
  return new AddInt(*this);
}



/********************   SubInt    ********************/
SubInt::SubInt(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

SubInt::SubInt(const SubInt & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

SubInt &SubInt::operator=(const SubInt & other)
{
  SubInt tmp(other);
  swap(tmp);
  return *this;
}

void SubInt::swap(SubInt & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

SubInt::~SubInt()
{
  delete(expr_1);
  delete(expr_2);

}

void SubInt::accept(Visitor *v)
{
  v->visitSubInt(this);
}

SubInt *SubInt::clone() const
{
  return new SubInt(*this);
}



/********************   MulInt    ********************/
MulInt::MulInt(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

MulInt::MulInt(const MulInt & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

MulInt &MulInt::operator=(const MulInt & other)
{
  MulInt tmp(other);
  swap(tmp);
  return *this;
}

void MulInt::swap(MulInt & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

MulInt::~MulInt()
{
  delete(expr_1);
  delete(expr_2);

}

void MulInt::accept(Visitor *v)
{
  v->visitMulInt(this);
}

MulInt *MulInt::clone() const
{
  return new MulInt(*this);
}



/********************   DivInt    ********************/
DivInt::DivInt(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

DivInt::DivInt(const DivInt & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

DivInt &DivInt::operator=(const DivInt & other)
{
  DivInt tmp(other);
  swap(tmp);
  return *this;
}

void DivInt::swap(DivInt & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

DivInt::~DivInt()
{
  delete(expr_1);
  delete(expr_2);

}

void DivInt::accept(Visitor *v)
{
  v->visitDivInt(this);
}

DivInt *DivInt::clone() const
{
  return new DivInt(*this);
}



/********************   EquInt    ********************/
EquInt::EquInt(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EquInt::EquInt(const EquInt & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EquInt &EquInt::operator=(const EquInt & other)
{
  EquInt tmp(other);
  swap(tmp);
  return *this;
}

void EquInt::swap(EquInt & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EquInt::~EquInt()
{
  delete(expr_1);
  delete(expr_2);

}

void EquInt::accept(Visitor *v)
{
  v->visitEquInt(this);
}

EquInt *EquInt::clone() const
{
  return new EquInt(*this);
}



/********************   LesInt    ********************/
LesInt::LesInt(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LesInt::LesInt(const LesInt & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LesInt &LesInt::operator=(const LesInt & other)
{
  LesInt tmp(other);
  swap(tmp);
  return *this;
}

void LesInt::swap(LesInt & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LesInt::~LesInt()
{
  delete(expr_1);
  delete(expr_2);

}

void LesInt::accept(Visitor *v)
{
  v->visitLesInt(this);
}

LesInt *LesInt::clone() const
{
  return new LesInt(*this);
}



/********************   ConstReal    ********************/
ConstReal::ConstReal(Double p1)
{
  double_ = p1;

}

ConstReal::ConstReal(const ConstReal & other)
{
  double_ = other.double_;

}

ConstReal &ConstReal::operator=(const ConstReal & other)
{
  ConstReal tmp(other);
  swap(tmp);
  return *this;
}

void ConstReal::swap(ConstReal & other)
{
  std::swap(double_, other.double_);

}

ConstReal::~ConstReal()
{

}

void ConstReal::accept(Visitor *v)
{
  v->visitConstReal(this);
}

ConstReal *ConstReal::clone() const
{
  return new ConstReal(*this);
}



/********************   ToReal    ********************/
ToReal::ToReal(Expr *p1)
{
  expr_ = p1;

}

ToReal::ToReal(const ToReal & other)
{
  expr_ = other.expr_->clone();

}

ToReal &ToReal::operator=(const ToReal & other)
{
  ToReal tmp(other);
  swap(tmp);
  return *this;
}

void ToReal::swap(ToReal & other)
{
  std::swap(expr_, other.expr_);

}

ToReal::~ToReal()
{
  delete(expr_);

}

void ToReal::accept(Visitor *v)
{
  v->visitToReal(this);
}

ToReal *ToReal::clone() const
{
  return new ToReal(*this);
}



/********************   AddReal    ********************/
AddReal::AddReal(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

AddReal::AddReal(const AddReal & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

AddReal &AddReal::operator=(const AddReal & other)
{
  AddReal tmp(other);
  swap(tmp);
  return *this;
}

void AddReal::swap(AddReal & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

AddReal::~AddReal()
{
  delete(expr_1);
  delete(expr_2);

}

void AddReal::accept(Visitor *v)
{
  v->visitAddReal(this);
}

AddReal *AddReal::clone() const
{
  return new AddReal(*this);
}



/********************   SubReal    ********************/
SubReal::SubReal(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

SubReal::SubReal(const SubReal & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

SubReal &SubReal::operator=(const SubReal & other)
{
  SubReal tmp(other);
  swap(tmp);
  return *this;
}

void SubReal::swap(SubReal & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

SubReal::~SubReal()
{
  delete(expr_1);
  delete(expr_2);

}

void SubReal::accept(Visitor *v)
{
  v->visitSubReal(this);
}

SubReal *SubReal::clone() const
{
  return new SubReal(*this);
}



/********************   MulReal    ********************/
MulReal::MulReal(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

MulReal::MulReal(const MulReal & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

MulReal &MulReal::operator=(const MulReal & other)
{
  MulReal tmp(other);
  swap(tmp);
  return *this;
}

void MulReal::swap(MulReal & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

MulReal::~MulReal()
{
  delete(expr_1);
  delete(expr_2);

}

void MulReal::accept(Visitor *v)
{
  v->visitMulReal(this);
}

MulReal *MulReal::clone() const
{
  return new MulReal(*this);
}



/********************   DivReal    ********************/
DivReal::DivReal(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

DivReal::DivReal(const DivReal & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

DivReal &DivReal::operator=(const DivReal & other)
{
  DivReal tmp(other);
  swap(tmp);
  return *this;
}

void DivReal::swap(DivReal & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

DivReal::~DivReal()
{
  delete(expr_1);
  delete(expr_2);

}

void DivReal::accept(Visitor *v)
{
  v->visitDivReal(this);
}

DivReal *DivReal::clone() const
{
  return new DivReal(*this);
}



/********************   EquReal    ********************/
EquReal::EquReal(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

EquReal::EquReal(const EquReal & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

EquReal &EquReal::operator=(const EquReal & other)
{
  EquReal tmp(other);
  swap(tmp);
  return *this;
}

void EquReal::swap(EquReal & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

EquReal::~EquReal()
{
  delete(expr_1);
  delete(expr_2);

}

void EquReal::accept(Visitor *v)
{
  v->visitEquReal(this);
}

EquReal *EquReal::clone() const
{
  return new EquReal(*this);
}



/********************   LesReal    ********************/
LesReal::LesReal(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LesReal::LesReal(const LesReal & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LesReal &LesReal::operator=(const LesReal & other)
{
  LesReal tmp(other);
  swap(tmp);
  return *this;
}

void LesReal::swap(LesReal & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LesReal::~LesReal()
{
  delete(expr_1);
  delete(expr_2);

}

void LesReal::accept(Visitor *v)
{
  v->visitLesReal(this);
}

LesReal *LesReal::clone() const
{
  return new LesReal(*this);
}



/********************   ReadInt    ********************/
ReadInt::ReadInt()
{

}

ReadInt::ReadInt(const ReadInt & other)
{

}

ReadInt &ReadInt::operator=(const ReadInt & other)
{
  ReadInt tmp(other);
  swap(tmp);
  return *this;
}

void ReadInt::swap(ReadInt & other)
{

}

ReadInt::~ReadInt()
{

}

void ReadInt::accept(Visitor *v)
{
  v->visitReadInt(this);
}

ReadInt *ReadInt::clone() const
{
  return new ReadInt(*this);
}



/********************   ReadReal    ********************/
ReadReal::ReadReal()
{

}

ReadReal::ReadReal(const ReadReal & other)
{

}

ReadReal &ReadReal::operator=(const ReadReal & other)
{
  ReadReal tmp(other);
  swap(tmp);
  return *this;
}

void ReadReal::swap(ReadReal & other)
{

}

ReadReal::~ReadReal()
{

}

void ReadReal::accept(Visitor *v)
{
  v->visitReadReal(this);
}

ReadReal *ReadReal::clone() const
{
  return new ReadReal(*this);
}



/********************   WriteInt    ********************/
WriteInt::WriteInt(Expr *p1)
{
  expr_ = p1;

}

WriteInt::WriteInt(const WriteInt & other)
{
  expr_ = other.expr_->clone();

}

WriteInt &WriteInt::operator=(const WriteInt & other)
{
  WriteInt tmp(other);
  swap(tmp);
  return *this;
}

void WriteInt::swap(WriteInt & other)
{
  std::swap(expr_, other.expr_);

}

WriteInt::~WriteInt()
{
  delete(expr_);

}

void WriteInt::accept(Visitor *v)
{
  v->visitWriteInt(this);
}

WriteInt *WriteInt::clone() const
{
  return new WriteInt(*this);
}



/********************   WriteReal    ********************/
WriteReal::WriteReal(Expr *p1)
{
  expr_ = p1;

}

WriteReal::WriteReal(const WriteReal & other)
{
  expr_ = other.expr_->clone();

}

WriteReal &WriteReal::operator=(const WriteReal & other)
{
  WriteReal tmp(other);
  swap(tmp);
  return *this;
}

void WriteReal::swap(WriteReal & other)
{
  std::swap(expr_, other.expr_);

}

WriteReal::~WriteReal()
{
  delete(expr_);

}

void WriteReal::accept(Visitor *v)
{
  v->visitWriteReal(this);
}

WriteReal *WriteReal::clone() const
{
  return new WriteReal(*this);
}



/********************   AbstractionField    ********************/
AbstractionField::AbstractionField(Type *p1, Ident p2)
{
  type_ = p1;
  ident_ = p2;

}

AbstractionField::AbstractionField(const AbstractionField & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;

}

AbstractionField &AbstractionField::operator=(const AbstractionField & other)
{
  AbstractionField tmp(other);
  swap(tmp);
  return *this;
}

void AbstractionField::swap(AbstractionField & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);

}

AbstractionField::~AbstractionField()
{
  delete(type_);

}

void AbstractionField::accept(Visitor *v)
{
  v->visitAbstractionField(this);
}

AbstractionField *AbstractionField::clone() const
{
  return new AbstractionField(*this);
}



/********************   WhereField    ********************/
WhereField::WhereField(Type *p1, Ident p2, Expr *p3)
{
  type_ = p1;
  ident_ = p2;
  expr_ = p3;

}

WhereField::WhereField(const WhereField & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

WhereField &WhereField::operator=(const WhereField & other)
{
  WhereField tmp(other);
  swap(tmp);
  return *this;
}

void WhereField::swap(WhereField & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

WhereField::~WhereField()
{
  delete(type_);
  delete(expr_);

}

void WhereField::accept(Visitor *v)
{
  v->visitWhereField(this);
}

WhereField *WhereField::clone() const
{
  return new WhereField(*this);
}



/********************   RecordField    ********************/
RecordField::RecordField(Ident p1, Expr *p2)
{
  ident_ = p1;
  expr_ = p2;

}

RecordField::RecordField(const RecordField & other)
{
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

RecordField &RecordField::operator=(const RecordField & other)
{
  RecordField tmp(other);
  swap(tmp);
  return *this;
}

void RecordField::swap(RecordField & other)
{
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

RecordField::~RecordField()
{
  delete(expr_);

}

void RecordField::accept(Visitor *v)
{
  v->visitRecordField(this);
}

RecordField *RecordField::clone() const
{
  return new RecordField(*this);
}



/********************   VariantField    ********************/
VariantField::VariantField(Ident p1, Ident p2, Expr *p3)
{
  ident_1 = p1;
  ident_2 = p2;
  expr_ = p3;

}

VariantField::VariantField(const VariantField & other)
{
  ident_1 = other.ident_1;
  ident_2 = other.ident_2;
  expr_ = other.expr_->clone();

}

VariantField &VariantField::operator=(const VariantField & other)
{
  VariantField tmp(other);
  swap(tmp);
  return *this;
}

void VariantField::swap(VariantField & other)
{
  std::swap(ident_1, other.ident_1);
  std::swap(ident_2, other.ident_2);
  std::swap(expr_, other.expr_);

}

VariantField::~VariantField()
{
  delete(expr_);

}

void VariantField::accept(Visitor *v)
{
  v->visitVariantField(this);
}

VariantField *VariantField::clone() const
{
  return new VariantField(*this);
}



/********************   Import    ********************/
Import::Import(String p1)
{
  string_ = p1;

}

Import::Import(const Import & other)
{
  string_ = other.string_;

}

Import &Import::operator=(const Import & other)
{
  Import tmp(other);
  swap(tmp);
  return *this;
}

void Import::swap(Import & other)
{
  std::swap(string_, other.string_);

}

Import::~Import()
{

}

void Import::accept(Visitor *v)
{
  v->visitImport(this);
}

Import *Import::clone() const
{
  return new Import(*this);
}



/********************   Definition    ********************/
Definition::Definition(Type *p1, Ident p2, Expr *p3)
{
  type_ = p1;
  ident_ = p2;
  expr_ = p3;

}

Definition::Definition(const Definition & other)
{
  type_ = other.type_->clone();
  ident_ = other.ident_;
  expr_ = other.expr_->clone();

}

Definition &Definition::operator=(const Definition & other)
{
  Definition tmp(other);
  swap(tmp);
  return *this;
}

void Definition::swap(Definition & other)
{
  std::swap(type_, other.type_);
  std::swap(ident_, other.ident_);
  std::swap(expr_, other.expr_);

}

Definition::~Definition()
{
  delete(type_);
  delete(expr_);

}

void Definition::accept(Visitor *v)
{
  v->visitDefinition(this);
}

Definition *Definition::clone() const
{
  return new Definition(*this);
}



/********************   TypeDefinition    ********************/
TypeDefinition::TypeDefinition(Ident p1, Type *p2)
{
  ident_ = p1;
  type_ = p2;

}

TypeDefinition::TypeDefinition(const TypeDefinition & other)
{
  ident_ = other.ident_;
  type_ = other.type_->clone();

}

TypeDefinition &TypeDefinition::operator=(const TypeDefinition & other)
{
  TypeDefinition tmp(other);
  swap(tmp);
  return *this;
}

void TypeDefinition::swap(TypeDefinition & other)
{
  std::swap(ident_, other.ident_);
  std::swap(type_, other.type_);

}

TypeDefinition::~TypeDefinition()
{
  delete(type_);

}

void TypeDefinition::accept(Visitor *v)
{
  v->visitTypeDefinition(this);
}

TypeDefinition *TypeDefinition::clone() const
{
  return new TypeDefinition(*this);
}



/********************   Assignment    ********************/
Assignment::Assignment(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Assignment::Assignment(const Assignment & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Assignment &Assignment::operator=(const Assignment & other)
{
  Assignment tmp(other);
  swap(tmp);
  return *this;
}

void Assignment::swap(Assignment & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Assignment::~Assignment()
{
  delete(expr_1);
  delete(expr_2);

}

void Assignment::accept(Visitor *v)
{
  v->visitAssignment(this);
}

Assignment *Assignment::clone() const
{
  return new Assignment(*this);
}



/********************   IfStatement    ********************/
IfStatement::IfStatement(Expr *p1, ListStatement *p2)
{
  expr_ = p1;
  liststatement_ = p2;

}

IfStatement::IfStatement(const IfStatement & other)
{
  expr_ = other.expr_->clone();
  liststatement_ = other.liststatement_->clone();

}

IfStatement &IfStatement::operator=(const IfStatement & other)
{
  IfStatement tmp(other);
  swap(tmp);
  return *this;
}

void IfStatement::swap(IfStatement & other)
{
  std::swap(expr_, other.expr_);
  std::swap(liststatement_, other.liststatement_);

}

IfStatement::~IfStatement()
{
  delete(expr_);
  delete(liststatement_);

}

void IfStatement::accept(Visitor *v)
{
  v->visitIfStatement(this);
}

IfStatement *IfStatement::clone() const
{
  return new IfStatement(*this);
}



/********************   IfElseStatement    ********************/
IfElseStatement::IfElseStatement(Expr *p1, ListStatement *p2, ListStatement *p3)
{
  expr_ = p1;
  liststatement_1 = p2;
  liststatement_2 = p3;

}

IfElseStatement::IfElseStatement(const IfElseStatement & other)
{
  expr_ = other.expr_->clone();
  liststatement_1 = other.liststatement_1->clone();
  liststatement_2 = other.liststatement_2->clone();

}

IfElseStatement &IfElseStatement::operator=(const IfElseStatement & other)
{
  IfElseStatement tmp(other);
  swap(tmp);
  return *this;
}

void IfElseStatement::swap(IfElseStatement & other)
{
  std::swap(expr_, other.expr_);
  std::swap(liststatement_1, other.liststatement_1);
  std::swap(liststatement_2, other.liststatement_2);

}

IfElseStatement::~IfElseStatement()
{
  delete(expr_);
  delete(liststatement_1);
  delete(liststatement_2);

}

void IfElseStatement::accept(Visitor *v)
{
  v->visitIfElseStatement(this);
}

IfElseStatement *IfElseStatement::clone() const
{
  return new IfElseStatement(*this);
}



/********************   Loop    ********************/
Loop::Loop(ListStatement *p1)
{
  liststatement_ = p1;

}

Loop::Loop(const Loop & other)
{
  liststatement_ = other.liststatement_->clone();

}

Loop &Loop::operator=(const Loop & other)
{
  Loop tmp(other);
  swap(tmp);
  return *this;
}

void Loop::swap(Loop & other)
{
  std::swap(liststatement_, other.liststatement_);

}

Loop::~Loop()
{
  delete(liststatement_);

}

void Loop::accept(Visitor *v)
{
  v->visitLoop(this);
}

Loop *Loop::clone() const
{
  return new Loop(*this);
}



/********************   Break    ********************/
Break::Break()
{

}

Break::Break(const Break & other)
{

}

Break &Break::operator=(const Break & other)
{
  Break tmp(other);
  swap(tmp);
  return *this;
}

void Break::swap(Break & other)
{

}

Break::~Break()
{

}

void Break::accept(Visitor *v)
{
  v->visitBreak(this);
}

Break *Break::clone() const
{
  return new Break(*this);
}



/********************   Continue    ********************/
Continue::Continue()
{

}

Continue::Continue(const Continue & other)
{

}

Continue &Continue::operator=(const Continue & other)
{
  Continue tmp(other);
  swap(tmp);
  return *this;
}

void Continue::swap(Continue & other)
{

}

Continue::~Continue()
{

}

void Continue::accept(Visitor *v)
{
  v->visitContinue(this);
}

Continue *Continue::clone() const
{
  return new Continue(*this);
}



/********************   Return    ********************/
Return::Return()
{

}

Return::Return(const Return & other)
{

}

Return &Return::operator=(const Return & other)
{
  Return tmp(other);
  swap(tmp);
  return *this;
}

void Return::swap(Return & other)
{

}

Return::~Return()
{

}

void Return::accept(Visitor *v)
{
  v->visitReturn(this);
}

Return *Return::clone() const
{
  return new Return(*this);
}



/********************   Eval    ********************/
Eval::Eval(Expr *p1)
{
  expr_ = p1;

}

Eval::Eval(const Eval & other)
{
  expr_ = other.expr_->clone();

}

Eval &Eval::operator=(const Eval & other)
{
  Eval tmp(other);
  swap(tmp);
  return *this;
}

void Eval::swap(Eval & other)
{
  std::swap(expr_, other.expr_);

}

Eval::~Eval()
{
  delete(expr_);

}

void Eval::accept(Visitor *v)
{
  v->visitEval(this);
}

Eval *Eval::clone() const
{
  return new Eval(*this);
}



/********************   AutoType    ********************/
AutoType::AutoType()
{

}

AutoType::AutoType(const AutoType & other)
{

}

AutoType &AutoType::operator=(const AutoType & other)
{
  AutoType tmp(other);
  swap(tmp);
  return *this;
}

void AutoType::swap(AutoType & other)
{

}

AutoType::~AutoType()
{

}

void AutoType::accept(Visitor *v)
{
  v->visitAutoType(this);
}

AutoType *AutoType::clone() const
{
  return new AutoType(*this);
}



/********************   BoolType    ********************/
BoolType::BoolType()
{

}

BoolType::BoolType(const BoolType & other)
{

}

BoolType &BoolType::operator=(const BoolType & other)
{
  BoolType tmp(other);
  swap(tmp);
  return *this;
}

void BoolType::swap(BoolType & other)
{

}

BoolType::~BoolType()
{

}

void BoolType::accept(Visitor *v)
{
  v->visitBoolType(this);
}

BoolType *BoolType::clone() const
{
  return new BoolType(*this);
}



/********************   NatType    ********************/
NatType::NatType()
{

}

NatType::NatType(const NatType & other)
{

}

NatType &NatType::operator=(const NatType & other)
{
  NatType tmp(other);
  swap(tmp);
  return *this;
}

void NatType::swap(NatType & other)
{

}

NatType::~NatType()
{

}

void NatType::accept(Visitor *v)
{
  v->visitNatType(this);
}

NatType *NatType::clone() const
{
  return new NatType(*this);
}



/********************   RefType    ********************/
RefType::RefType(Type *p1)
{
  type_ = p1;

}

RefType::RefType(const RefType & other)
{
  type_ = other.type_->clone();

}

RefType &RefType::operator=(const RefType & other)
{
  RefType tmp(other);
  swap(tmp);
  return *this;
}

void RefType::swap(RefType & other)
{
  std::swap(type_, other.type_);

}

RefType::~RefType()
{
  delete(type_);

}

void RefType::accept(Visitor *v)
{
  v->visitRefType(this);
}

RefType *RefType::clone() const
{
  return new RefType(*this);
}



/********************   VarType    ********************/
VarType::VarType(Ident p1)
{
  ident_ = p1;

}

VarType::VarType(const VarType & other)
{
  ident_ = other.ident_;

}

VarType &VarType::operator=(const VarType & other)
{
  VarType tmp(other);
  swap(tmp);
  return *this;
}

void VarType::swap(VarType & other)
{
  std::swap(ident_, other.ident_);

}

VarType::~VarType()
{

}

void VarType::accept(Visitor *v)
{
  v->visitVarType(this);
}

VarType *VarType::clone() const
{
  return new VarType(*this);
}



/********************   UniType    ********************/
UniType::UniType(Ident p1, Type *p2)
{
  ident_ = p1;
  type_ = p2;

}

UniType::UniType(const UniType & other)
{
  ident_ = other.ident_;
  type_ = other.type_->clone();

}

UniType &UniType::operator=(const UniType & other)
{
  UniType tmp(other);
  swap(tmp);
  return *this;
}

void UniType::swap(UniType & other)
{
  std::swap(ident_, other.ident_);
  std::swap(type_, other.type_);

}

UniType::~UniType()
{
  delete(type_);

}

void UniType::accept(Visitor *v)
{
  v->visitUniType(this);
}

UniType *UniType::clone() const
{
  return new UniType(*this);
}



/********************   FunType    ********************/
FunType::FunType(Type *p1, Type *p2)
{
  type_1 = p1;
  type_2 = p2;

}

FunType::FunType(const FunType & other)
{
  type_1 = other.type_1->clone();
  type_2 = other.type_2->clone();

}

FunType &FunType::operator=(const FunType & other)
{
  FunType tmp(other);
  swap(tmp);
  return *this;
}

void FunType::swap(FunType & other)
{
  std::swap(type_1, other.type_1);
  std::swap(type_2, other.type_2);

}

FunType::~FunType()
{
  delete(type_1);
  delete(type_2);

}

void FunType::accept(Visitor *v)
{
  v->visitFunType(this);
}

FunType *FunType::clone() const
{
  return new FunType(*this);
}



/********************   TupleType    ********************/
TupleType::TupleType(ListType *p1)
{
  listtype_ = p1;

}

TupleType::TupleType(const TupleType & other)
{
  listtype_ = other.listtype_->clone();

}

TupleType &TupleType::operator=(const TupleType & other)
{
  TupleType tmp(other);
  swap(tmp);
  return *this;
}

void TupleType::swap(TupleType & other)
{
  std::swap(listtype_, other.listtype_);

}

TupleType::~TupleType()
{
  delete(listtype_);

}

void TupleType::accept(Visitor *v)
{
  v->visitTupleType(this);
}

TupleType *TupleType::clone() const
{
  return new TupleType(*this);
}



/********************   RecordType    ********************/
RecordType::RecordType(ListRecordTypeField_ *p1)
{
  listrecordtypefield__ = p1;

}

RecordType::RecordType(const RecordType & other)
{
  listrecordtypefield__ = other.listrecordtypefield__->clone();

}

RecordType &RecordType::operator=(const RecordType & other)
{
  RecordType tmp(other);
  swap(tmp);
  return *this;
}

void RecordType::swap(RecordType & other)
{
  std::swap(listrecordtypefield__, other.listrecordtypefield__);

}

RecordType::~RecordType()
{
  delete(listrecordtypefield__);

}

void RecordType::accept(Visitor *v)
{
  v->visitRecordType(this);
}

RecordType *RecordType::clone() const
{
  return new RecordType(*this);
}



/********************   VariantType    ********************/
VariantType::VariantType(ListVariantTypeField_ *p1)
{
  listvarianttypefield__ = p1;

}

VariantType::VariantType(const VariantType & other)
{
  listvarianttypefield__ = other.listvarianttypefield__->clone();

}

VariantType &VariantType::operator=(const VariantType & other)
{
  VariantType tmp(other);
  swap(tmp);
  return *this;
}

void VariantType::swap(VariantType & other)
{
  std::swap(listvarianttypefield__, other.listvarianttypefield__);

}

VariantType::~VariantType()
{
  delete(listvarianttypefield__);

}

void VariantType::accept(Visitor *v)
{
  v->visitVariantType(this);
}

VariantType *VariantType::clone() const
{
  return new VariantType(*this);
}



/********************   ArrayType    ********************/
ArrayType::ArrayType(Type *p1)
{
  type_ = p1;

}

ArrayType::ArrayType(const ArrayType & other)
{
  type_ = other.type_->clone();

}

ArrayType &ArrayType::operator=(const ArrayType & other)
{
  ArrayType tmp(other);
  swap(tmp);
  return *this;
}

void ArrayType::swap(ArrayType & other)
{
  std::swap(type_, other.type_);

}

ArrayType::~ArrayType()
{
  delete(type_);

}

void ArrayType::accept(Visitor *v)
{
  v->visitArrayType(this);
}

ArrayType *ArrayType::clone() const
{
  return new ArrayType(*this);
}



/********************   IntType    ********************/
IntType::IntType()
{

}

IntType::IntType(const IntType & other)
{

}

IntType &IntType::operator=(const IntType & other)
{
  IntType tmp(other);
  swap(tmp);
  return *this;
}

void IntType::swap(IntType & other)
{

}

IntType::~IntType()
{

}

void IntType::accept(Visitor *v)
{
  v->visitIntType(this);
}

IntType *IntType::clone() const
{
  return new IntType(*this);
}



/********************   RealType    ********************/
RealType::RealType()
{

}

RealType::RealType(const RealType & other)
{

}

RealType &RealType::operator=(const RealType & other)
{
  RealType tmp(other);
  swap(tmp);
  return *this;
}

void RealType::swap(RealType & other)
{

}

RealType::~RealType()
{

}

void RealType::accept(Visitor *v)
{
  v->visitRealType(this);
}

RealType *RealType::clone() const
{
  return new RealType(*this);
}



/********************   RecordTypeField    ********************/
RecordTypeField::RecordTypeField(Ident p1, Type *p2)
{
  ident_ = p1;
  type_ = p2;

}

RecordTypeField::RecordTypeField(const RecordTypeField & other)
{
  ident_ = other.ident_;
  type_ = other.type_->clone();

}

RecordTypeField &RecordTypeField::operator=(const RecordTypeField & other)
{
  RecordTypeField tmp(other);
  swap(tmp);
  return *this;
}

void RecordTypeField::swap(RecordTypeField & other)
{
  std::swap(ident_, other.ident_);
  std::swap(type_, other.type_);

}

RecordTypeField::~RecordTypeField()
{
  delete(type_);

}

void RecordTypeField::accept(Visitor *v)
{
  v->visitRecordTypeField(this);
}

RecordTypeField *RecordTypeField::clone() const
{
  return new RecordTypeField(*this);
}



/********************   VariantTypeField    ********************/
VariantTypeField::VariantTypeField(Ident p1, Type *p2)
{
  ident_ = p1;
  type_ = p2;

}

VariantTypeField::VariantTypeField(const VariantTypeField & other)
{
  ident_ = other.ident_;
  type_ = other.type_->clone();

}

VariantTypeField &VariantTypeField::operator=(const VariantTypeField & other)
{
  VariantTypeField tmp(other);
  swap(tmp);
  return *this;
}

void VariantTypeField::swap(VariantTypeField & other)
{
  std::swap(ident_, other.ident_);
  std::swap(type_, other.type_);

}

VariantTypeField::~VariantTypeField()
{
  delete(type_);

}

void VariantTypeField::accept(Visitor *v)
{
  v->visitVariantTypeField(this);
}

VariantTypeField *VariantTypeField::clone() const
{
  return new VariantTypeField(*this);
}




/********************   ListExpr    ********************/

ListExpr::ListExpr() { }

ListExpr::ListExpr(const ListExpr & other) {
  for (auto i : other)
    push_back(i->clone());
}

void ListExpr::accept(Visitor *v)
{
  v->visitListExpr(this);
}

ListExpr *ListExpr::clone() const
{
  return new ListExpr(*this);
}

ListExpr* consListExpr(Expr* x, ListExpr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAbstractionField_    ********************/

ListAbstractionField_::ListAbstractionField_() { }

ListAbstractionField_::ListAbstractionField_(const ListAbstractionField_ & other) {
  for (auto i : other)
    push_back(i->clone());
}

void ListAbstractionField_::accept(Visitor *v)
{
  v->visitListAbstractionField_(this);
}

ListAbstractionField_ *ListAbstractionField_::clone() const
{
  return new ListAbstractionField_(*this);
}

ListAbstractionField_* consListAbstractionField_(AbstractionField_* x, ListAbstractionField_* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListWhereField_    ********************/

ListWhereField_::ListWhereField_() { }

ListWhereField_::ListWhereField_(const ListWhereField_ & other) {
  for (auto i : other)
    push_back(i->clone());
}

void ListWhereField_::accept(Visitor *v)
{
  v->visitListWhereField_(this);
}

ListWhereField_ *ListWhereField_::clone() const
{
  return new ListWhereField_(*this);
}

ListWhereField_* consListWhereField_(WhereField_* x, ListWhereField_* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListRecordField_    ********************/

ListRecordField_::ListRecordField_() { }

ListRecordField_::ListRecordField_(const ListRecordField_ & other) {
  for (auto i : other)
    push_back(i->clone());
}

void ListRecordField_::accept(Visitor *v)
{
  v->visitListRecordField_(this);
}

ListRecordField_ *ListRecordField_::clone() const
{
  return new ListRecordField_(*this);
}

ListRecordField_* consListRecordField_(RecordField_* x, ListRecordField_* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListVariantField_    ********************/

ListVariantField_::ListVariantField_() { }

ListVariantField_::ListVariantField_(const ListVariantField_ & other) {
  for (auto i : other)
    push_back(i->clone());
}

void ListVariantField_::accept(Visitor *v)
{
  v->visitListVariantField_(this);
}

ListVariantField_ *ListVariantField_::clone() const
{
  return new ListVariantField_(*this);
}

ListVariantField_* consListVariantField_(VariantField_* x, ListVariantField_* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListStatement    ********************/

ListStatement::ListStatement() { }

ListStatement::ListStatement(const ListStatement & other) {
  for (auto i : other)
    push_back(i->clone());
}

void ListStatement::accept(Visitor *v)
{
  v->visitListStatement(this);
}

ListStatement *ListStatement::clone() const
{
  return new ListStatement(*this);
}

ListStatement* consListStatement(Statement* x, ListStatement* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListType    ********************/

ListType::ListType() { }

ListType::ListType(const ListType & other) {
  for (auto i : other)
    push_back(i->clone());
}

void ListType::accept(Visitor *v)
{
  v->visitListType(this);
}

ListType *ListType::clone() const
{
  return new ListType(*this);
}

ListType* consListType(Type* x, ListType* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListRecordTypeField_    ********************/

ListRecordTypeField_::ListRecordTypeField_() { }

ListRecordTypeField_::ListRecordTypeField_(const ListRecordTypeField_ & other) {
  for (auto i : other)
    push_back(i->clone());
}

void ListRecordTypeField_::accept(Visitor *v)
{
  v->visitListRecordTypeField_(this);
}

ListRecordTypeField_ *ListRecordTypeField_::clone() const
{
  return new ListRecordTypeField_(*this);
}

ListRecordTypeField_* consListRecordTypeField_(RecordTypeField_* x, ListRecordTypeField_* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListVariantTypeField_    ********************/

ListVariantTypeField_::ListVariantTypeField_() { }

ListVariantTypeField_::ListVariantTypeField_(const ListVariantTypeField_ & other) {
  for (auto i : other)
    push_back(i->clone());
}

void ListVariantTypeField_::accept(Visitor *v)
{
  v->visitListVariantTypeField_(this);
}

ListVariantTypeField_ *ListVariantTypeField_::clone() const
{
  return new ListVariantTypeField_(*this);
}

ListVariantTypeField_* consListVariantTypeField_(VariantTypeField_* x, ListVariantTypeField_* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}





