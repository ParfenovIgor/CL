/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the syntax_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE syntax__scan_string(const char *str, yyscan_t scanner);
extern void syntax__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void syntax_lex_destroy(yyscan_t scanner);
extern char* syntax_get_text(yyscan_t scanner);

extern yyscan_t syntax__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Program* program_;
  ListExpr* listexpr_;
  Expr* expr_;
  ListAbstractionField_* listabstractionfield__;
  AbstractionField_* abstractionfield__;
  ListWhereField_* listwherefield__;
  WhereField_* wherefield__;
  ListRecordField_* listrecordfield__;
  RecordField_* recordfield__;
  ListVariantField_* listvariantfield__;
  VariantField_* variantfield__;
  Statement* statement_;
  ListStatement* liststatement_;
  ListType* listtype_;
  Type* type_;
  ListRecordTypeField_* listrecordtypefield__;
  RecordTypeField_* recordtypefield__;
  ListVariantTypeField_* listvarianttypefield__;
  VariantTypeField_* varianttypefield__;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, syntax_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _SYMB_1        /* $0 */
%token          _PERCENT       /* % */
%token          _LPAREN        /* ( */
%token          _RPAREN        /* ) */
%token          _STAR          /* * */
%token          _COMMA         /* , */
%token          _RARROW        /* -> */
%token          _DOT           /* . */
%token          _COLON         /* : */
%token          _SEMI          /* ; */
%token          _LT            /* < */
%token          _LARROW        /* <- */
%token          _EQ            /* = */
%token          _RDARROW       /* => */
%token          _GT            /* > */
%token          _KW_Bool       /* Bool */
%token          _KW_Int        /* Int */
%token          _KW_Nat        /* Nat */
%token          _KW_Real       /* Real */
%token          _KW_Ref        /* Ref */
%token          _LBRACK        /* [ */
%token          _RBRACK        /* ] */
%token          _UNDERSCORE    /* _ */
%token          _KW_as         /* as */
%token          _KW_break      /* break */
%token          _KW_case       /* case */
%token          _KW_continue   /* continue */
%token          _KW_def        /* def */
%token          _KW_else       /* else */
%token          _KW_eval       /* eval */
%token          _KW_false      /* false */
%token          _KW_fix        /* fix */
%token          _KW_fun        /* fun */
%token          _KW_get        /* get */
%token          _SYMB_16       /* i* */
%token          _SYMB_14       /* i+ */
%token          _SYMB_15       /* i- */
%token          _SYMB_17       /* i/ */
%token          _SYMB_19       /* i< */
%token          _SYMB_18       /* i= */
%token          _KW_if         /* if */
%token          _KW_import     /* import */
%token          _KW_iszero     /* iszero */
%token          _KW_len        /* len */
%token          _KW_loop       /* loop */
%token          _KW_of         /* of */
%token          _KW_pop        /* pop */
%token          _KW_pred       /* pred */
%token          _KW_push       /* push */
%token          _SYMB_22       /* r* */
%token          _SYMB_20       /* r+ */
%token          _SYMB_21       /* r- */
%token          _SYMB_23       /* r/ */
%token          _SYMB_25       /* r< */
%token          _SYMB_24       /* r= */
%token          _KW_readInt    /* readInt */
%token          _KW_readReal   /* readReal */
%token          _KW_ref        /* ref */
%token          _KW_ret        /* ret */
%token          _KW_return     /* return */
%token          _KW_succ       /* succ */
%token          _KW_then       /* then */
%token          _KW_toInt      /* toInt */
%token          _KW_toReal     /* toReal */
%token          _KW_true       /* true */
%token          _KW_typedef    /* typedef */
%token          _KW_uni        /* uni */
%token          _KW_where      /* where */
%token          _KW_writeInt   /* writeInt */
%token          _KW_writeReal  /* writeReal */
%token          _LBRACE        /* { */
%token          _BAR           /* | */
%token          _RBRACE        /* } */
%token          _SYMB_6        /* ~> */
%token<_string> _STRING_
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_
%token<_string> _IDENT_

%type <program_> Program
%type <listexpr_> ListExpr
%type <expr_> Expr8
%type <expr_> Expr3
%type <expr_> Expr1
%type <expr_> Expr2
%type <expr_> Expr
%type <expr_> Expr7
%type <expr_> Expr5
%type <expr_> Expr6
%type <expr_> Expr4
%type <listabstractionfield__> ListAbstractionField_
%type <abstractionfield__> AbstractionField_
%type <listwherefield__> ListWhereField_
%type <wherefield__> WhereField_
%type <listrecordfield__> ListRecordField_
%type <recordfield__> RecordField_
%type <listvariantfield__> ListVariantField_
%type <variantfield__> VariantField_
%type <statement_> Statement
%type <liststatement_> ListStatement
%type <listtype_> ListType
%type <type_> Type
%type <listrecordtypefield__> ListRecordTypeField_
%type <recordtypefield__> RecordTypeField_
%type <listvarianttypefield__> ListVariantTypeField_
%type <varianttypefield__> VariantTypeField_

%start Program

%%

Program : ListStatement { std::reverse($1->begin(),$1->end()) ;$$ = new ProgramRoot($1); result->program_ = $$; }
;
ListExpr : /* empty */ { $$ = new ListExpr(); result->listexpr_ = $$; }
  | Expr { $$ = new ListExpr(); $$->push_back($1); result->listexpr_ = $$; }
  | Expr _COMMA ListExpr { $3->push_back($1); $$ = $3; result->listexpr_ = $$; }
;
Expr8 : _KW_true { $$ = new ConstTrue(); result->expr_ = $$; }
  | _KW_false { $$ = new ConstFalse(); result->expr_ = $$; }
  | _SYMB_1 { $$ = new ConstZero(); result->expr_ = $$; }
  | _IDENT_ { $$ = new Var($1); result->expr_ = $$; }
  | _LT ListExpr _GT { std::reverse($2->begin(),$2->end()) ;$$ = new Tuple($2); result->expr_ = $$; }
  | Expr8 _DOT _INTEGER_ { $$ = new TupleGet($1, $3); result->expr_ = $$; }
  | _LBRACE ListRecordField_ _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new Record($2); result->expr_ = $$; }
  | Expr8 _DOT _IDENT_ { $$ = new RecordGet($1, $3); result->expr_ = $$; }
  | _LT _IDENT_ _EQ Expr _GT _KW_as Type { $$ = new Variant($2, $4, $7); result->expr_ = $$; }
  | _KW_case Expr _KW_of ListVariantField_ { std::reverse($4->begin(),$4->end()) ;$$ = new VariantCase($2, $4); result->expr_ = $$; }
  | _LBRACK ListExpr _RBRACK { std::reverse($2->begin(),$2->end()) ;$$ = new Array($2); result->expr_ = $$; }
  | _KW_get _LPAREN Expr _COMMA Expr _RPAREN { $$ = new ArrayGet($3, $5); result->expr_ = $$; }
  | _KW_push _LPAREN Expr _COMMA Expr _RPAREN { $$ = new ArrayPush($3, $5); result->expr_ = $$; }
  | _KW_pop _LPAREN Expr _RPAREN { $$ = new ArrayPop($3); result->expr_ = $$; }
  | _KW_len _LPAREN Expr _RPAREN { $$ = new ArrayLen($3); result->expr_ = $$; }
  | _INTEGER_ { $$ = new ConstInt($1); result->expr_ = $$; }
  | _DOUBLE_ { $$ = new ConstReal($1); result->expr_ = $$; }
  | _LPAREN Expr _RPAREN { $$ = $2; result->expr_ = $$; }
;
Expr3 : _KW_if Expr _KW_then Expr _KW_else Expr { $$ = new If($2, $4, $6); result->expr_ = $$; }
  | _KW_succ Expr3 { $$ = new Succ($2); result->expr_ = $$; }
  | _KW_pred Expr3 { $$ = new Pred($2); result->expr_ = $$; }
  | _KW_iszero Expr3 { $$ = new IsZero($2); result->expr_ = $$; }
  | _KW_toInt _LPAREN Expr _RPAREN { $$ = new ToInt($3); result->expr_ = $$; }
  | _KW_toReal _LPAREN Expr _RPAREN { $$ = new ToReal($3); result->expr_ = $$; }
  | Expr4 { $$ = $1; result->expr_ = $$; }
;
Expr1 : _KW_fun _LPAREN Type _IDENT_ _RPAREN _LBRACE ListStatement _KW_ret Expr _RBRACE { std::reverse($7->begin(),$7->end()) ;$$ = new Abstraction($3, $4, $7, $9); result->expr_ = $$; }
  | _KW_fun _LPAREN ListAbstractionField_ _RPAREN _LBRACE ListStatement _KW_ret Expr _RBRACE { std::reverse($3->begin(),$3->end()) ; std::reverse($6->begin(),$6->end()) ;$$ = new MultiAbstraction($3, $6, $8); result->expr_ = $$; }
  | _KW_uni _IDENT_ _SYMB_6 Expr1 { $$ = new TypeAbstraction($2, $4); result->expr_ = $$; }
  | _KW_fix Expr1 { $$ = new Fix($2); result->expr_ = $$; }
  | _KW_readInt { $$ = new ReadInt(); result->expr_ = $$; }
  | _KW_readReal { $$ = new ReadReal(); result->expr_ = $$; }
  | _KW_writeInt Expr1 { $$ = new WriteInt($2); result->expr_ = $$; }
  | _KW_writeReal Expr1 { $$ = new WriteReal($2); result->expr_ = $$; }
  | Expr2 { $$ = $1; result->expr_ = $$; }
;
Expr2 : Expr2 Expr3 { $$ = new Application($1, $2); result->expr_ = $$; }
  | Expr2 _LBRACK Type _RBRACK { $$ = new TypeApplication($1, $3); result->expr_ = $$; }
  | Expr3 { $$ = $1; result->expr_ = $$; }
;
Expr : Expr1 _KW_where Type _IDENT_ _EQ Expr { $$ = new Where($1, $3, $4, $6); result->expr_ = $$; }
  | Expr _KW_where _LBRACE ListWhereField_ _RBRACE { std::reverse($4->begin(),$4->end()) ;$$ = new MultiWhere($1, $4); result->expr_ = $$; }
  | Expr1 { $$ = $1; result->expr_ = $$; }
;
Expr7 : _KW_ref Expr7 { $$ = new Reference($2); result->expr_ = $$; }
  | _STAR Expr7 { $$ = new Dereference($2); result->expr_ = $$; }
  | Expr8 { $$ = $1; result->expr_ = $$; }
;
Expr5 : Expr5 _SYMB_14 Expr6 { $$ = new AddInt($1, $3); result->expr_ = $$; }
  | Expr5 _SYMB_15 Expr6 { $$ = new SubInt($1, $3); result->expr_ = $$; }
  | Expr5 _SYMB_20 Expr6 { $$ = new AddReal($1, $3); result->expr_ = $$; }
  | Expr5 _SYMB_21 Expr6 { $$ = new SubReal($1, $3); result->expr_ = $$; }
  | Expr6 { $$ = $1; result->expr_ = $$; }
;
Expr6 : Expr6 _SYMB_16 Expr7 { $$ = new MulInt($1, $3); result->expr_ = $$; }
  | Expr6 _SYMB_17 Expr7 { $$ = new DivInt($1, $3); result->expr_ = $$; }
  | Expr6 _SYMB_22 Expr7 { $$ = new MulReal($1, $3); result->expr_ = $$; }
  | Expr6 _SYMB_23 Expr7 { $$ = new DivReal($1, $3); result->expr_ = $$; }
  | Expr7 { $$ = $1; result->expr_ = $$; }
;
Expr4 : Expr4 _SYMB_18 Expr5 { $$ = new EquInt($1, $3); result->expr_ = $$; }
  | Expr4 _SYMB_19 Expr5 { $$ = new LesInt($1, $3); result->expr_ = $$; }
  | Expr4 _SYMB_24 Expr5 { $$ = new EquReal($1, $3); result->expr_ = $$; }
  | Expr4 _SYMB_25 Expr5 { $$ = new LesReal($1, $3); result->expr_ = $$; }
  | Expr5 { $$ = $1; result->expr_ = $$; }
;
ListAbstractionField_ : /* empty */ { $$ = new ListAbstractionField_(); result->listabstractionfield__ = $$; }
  | AbstractionField_ { $$ = new ListAbstractionField_(); $$->push_back($1); result->listabstractionfield__ = $$; }
  | AbstractionField_ _COMMA ListAbstractionField_ { $3->push_back($1); $$ = $3; result->listabstractionfield__ = $$; }
;
AbstractionField_ : Type _IDENT_ { $$ = new AbstractionField($1, $2); result->abstractionfield__ = $$; }
;
ListWhereField_ : /* empty */ { $$ = new ListWhereField_(); result->listwherefield__ = $$; }
  | WhereField_ { $$ = new ListWhereField_(); $$->push_back($1); result->listwherefield__ = $$; }
  | WhereField_ _COMMA ListWhereField_ { $3->push_back($1); $$ = $3; result->listwherefield__ = $$; }
;
WhereField_ : Type _IDENT_ _EQ Expr { $$ = new WhereField($1, $2, $4); result->wherefield__ = $$; }
;
ListRecordField_ : /* empty */ { $$ = new ListRecordField_(); result->listrecordfield__ = $$; }
  | RecordField_ { $$ = new ListRecordField_(); $$->push_back($1); result->listrecordfield__ = $$; }
  | RecordField_ _COMMA ListRecordField_ { $3->push_back($1); $$ = $3; result->listrecordfield__ = $$; }
;
RecordField_ : _IDENT_ _EQ Expr { $$ = new RecordField($1, $3); result->recordfield__ = $$; }
;
ListVariantField_ : /* empty */ { $$ = new ListVariantField_(); result->listvariantfield__ = $$; }
  | VariantField_ { $$ = new ListVariantField_(); $$->push_back($1); result->listvariantfield__ = $$; }
  | VariantField_ _BAR ListVariantField_ { $3->push_back($1); $$ = $3; result->listvariantfield__ = $$; }
;
VariantField_ : _LT _IDENT_ _EQ _IDENT_ _GT _RDARROW Expr { $$ = new VariantField($2, $4, $7); result->variantfield__ = $$; }
;
Statement : _KW_import _STRING_ { $$ = new Import($2); result->statement_ = $$; }
  | _KW_def Type _IDENT_ _EQ Expr { $$ = new Definition($2, $3, $5); result->statement_ = $$; }
  | _KW_typedef _IDENT_ _EQ Type { $$ = new TypeDefinition($2, $4); result->statement_ = $$; }
  | Expr _LARROW Expr { $$ = new Assignment($1, $3); result->statement_ = $$; }
  | _KW_if _LPAREN Expr _RPAREN _LBRACE ListStatement _RBRACE { std::reverse($6->begin(),$6->end()) ;$$ = new IfStatement($3, $6); result->statement_ = $$; }
  | _KW_if _LPAREN Expr _RPAREN _LBRACE ListStatement _RBRACE _KW_else _LBRACE ListStatement _RBRACE { std::reverse($6->begin(),$6->end()) ; std::reverse($10->begin(),$10->end()) ;$$ = new IfElseStatement($3, $6, $10); result->statement_ = $$; }
  | _KW_loop _LBRACE ListStatement _RBRACE { std::reverse($3->begin(),$3->end()) ;$$ = new Loop($3); result->statement_ = $$; }
  | _KW_break { $$ = new Break(); result->statement_ = $$; }
  | _KW_continue { $$ = new Continue(); result->statement_ = $$; }
  | _KW_return { $$ = new Return(); result->statement_ = $$; }
  | _KW_eval Expr { $$ = new Eval($2); result->statement_ = $$; }
;
ListStatement : /* empty */ { $$ = new ListStatement(); result->liststatement_ = $$; }
  | Statement { $$ = new ListStatement(); $$->push_back($1); result->liststatement_ = $$; }
  | Statement _SEMI ListStatement { $3->push_back($1); $$ = $3; result->liststatement_ = $$; }
;
ListType : /* empty */ { $$ = new ListType(); result->listtype_ = $$; }
  | Type { $$ = new ListType(); $$->push_back($1); result->listtype_ = $$; }
  | Type _COMMA ListType { $3->push_back($1); $$ = $3; result->listtype_ = $$; }
;
Type : _UNDERSCORE { $$ = new AutoType(); result->type_ = $$; }
  | _KW_Bool { $$ = new BoolType(); result->type_ = $$; }
  | _KW_Nat { $$ = new NatType(); result->type_ = $$; }
  | _KW_Ref Type { $$ = new RefType($2); result->type_ = $$; }
  | _IDENT_ { $$ = new VarType($1); result->type_ = $$; }
  | _PERCENT _IDENT_ _DOT Type { $$ = new UniType($2, $4); result->type_ = $$; }
  | Type _RARROW Type { $$ = new FunType($1, $3); result->type_ = $$; }
  | _LT ListType _GT { std::reverse($2->begin(),$2->end()) ;$$ = new TupleType($2); result->type_ = $$; }
  | _LBRACE ListRecordTypeField_ _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new RecordType($2); result->type_ = $$; }
  | _LT ListVariantTypeField_ _GT { std::reverse($2->begin(),$2->end()) ;$$ = new VariantType($2); result->type_ = $$; }
  | _LBRACK Type _RBRACK { $$ = new ArrayType($2); result->type_ = $$; }
  | _KW_Int { $$ = new IntType(); result->type_ = $$; }
  | _KW_Real { $$ = new RealType(); result->type_ = $$; }
  | _LPAREN Type _RPAREN { $$ = $2; result->type_ = $$; }
;
ListRecordTypeField_ : /* empty */ { $$ = new ListRecordTypeField_(); result->listrecordtypefield__ = $$; }
  | RecordTypeField_ { $$ = new ListRecordTypeField_(); $$->push_back($1); result->listrecordtypefield__ = $$; }
  | RecordTypeField_ _COMMA ListRecordTypeField_ { $3->push_back($1); $$ = $3; result->listrecordtypefield__ = $$; }
;
RecordTypeField_ : _IDENT_ _COLON Type { $$ = new RecordTypeField($1, $3); result->recordtypefield__ = $$; }
;
ListVariantTypeField_ : /* empty */ { $$ = new ListVariantTypeField_(); result->listvarianttypefield__ = $$; }
  | VariantTypeField_ { $$ = new ListVariantTypeField_(); $$->push_back($1); result->listvarianttypefield__ = $$; }
  | VariantTypeField_ _COMMA ListVariantTypeField_ { $3->push_back($1); $$ = $3; result->listvarianttypefield__ = $$; }
;
VariantTypeField_ : _IDENT_ _COLON Type { $$ = new VariantTypeField($1, $3); result->varianttypefield__ = $$; }
;

%%


/* Entrypoint: parse Program* from file. */
Program* pProgram(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Program* from string. */
Program* psProgram(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse ListExpr* from file. */
ListExpr* pListExpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpr_->begin(), result.listexpr_->end());
    return result.listexpr_;
  }
}

/* Entrypoint: parse ListExpr* from string. */
ListExpr* psListExpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpr_->begin(), result.listexpr_->end());
    return result.listexpr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr8(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr8(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr7(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr7(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr6(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr6(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse ListAbstractionField_* from file. */
ListAbstractionField_* pListAbstractionField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listabstractionfield__->begin(), result.listabstractionfield__->end());
    return result.listabstractionfield__;
  }
}

/* Entrypoint: parse ListAbstractionField_* from string. */
ListAbstractionField_* psListAbstractionField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listabstractionfield__->begin(), result.listabstractionfield__->end());
    return result.listabstractionfield__;
  }
}

/* Entrypoint: parse AbstractionField_* from file. */
AbstractionField_* pAbstractionField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.abstractionfield__;
  }
}

/* Entrypoint: parse AbstractionField_* from string. */
AbstractionField_* psAbstractionField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.abstractionfield__;
  }
}

/* Entrypoint: parse ListWhereField_* from file. */
ListWhereField_* pListWhereField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listwherefield__->begin(), result.listwherefield__->end());
    return result.listwherefield__;
  }
}

/* Entrypoint: parse ListWhereField_* from string. */
ListWhereField_* psListWhereField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listwherefield__->begin(), result.listwherefield__->end());
    return result.listwherefield__;
  }
}

/* Entrypoint: parse WhereField_* from file. */
WhereField_* pWhereField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.wherefield__;
  }
}

/* Entrypoint: parse WhereField_* from string. */
WhereField_* psWhereField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.wherefield__;
  }
}

/* Entrypoint: parse ListRecordField_* from file. */
ListRecordField_* pListRecordField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listrecordfield__->begin(), result.listrecordfield__->end());
    return result.listrecordfield__;
  }
}

/* Entrypoint: parse ListRecordField_* from string. */
ListRecordField_* psListRecordField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listrecordfield__->begin(), result.listrecordfield__->end());
    return result.listrecordfield__;
  }
}

/* Entrypoint: parse RecordField_* from file. */
RecordField_* pRecordField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.recordfield__;
  }
}

/* Entrypoint: parse RecordField_* from string. */
RecordField_* psRecordField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.recordfield__;
  }
}

/* Entrypoint: parse ListVariantField_* from file. */
ListVariantField_* pListVariantField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listvariantfield__->begin(), result.listvariantfield__->end());
    return result.listvariantfield__;
  }
}

/* Entrypoint: parse ListVariantField_* from string. */
ListVariantField_* psListVariantField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listvariantfield__->begin(), result.listvariantfield__->end());
    return result.listvariantfield__;
  }
}

/* Entrypoint: parse VariantField_* from file. */
VariantField_* pVariantField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variantfield__;
  }
}

/* Entrypoint: parse VariantField_* from string. */
VariantField_* psVariantField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.variantfield__;
  }
}

/* Entrypoint: parse Statement* from file. */
Statement* pStatement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statement_;
  }
}

/* Entrypoint: parse Statement* from string. */
Statement* psStatement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.statement_;
  }
}

/* Entrypoint: parse ListStatement* from file. */
ListStatement* pListStatement(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststatement_->begin(), result.liststatement_->end());
    return result.liststatement_;
  }
}

/* Entrypoint: parse ListStatement* from string. */
ListStatement* psListStatement(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.liststatement_->begin(), result.liststatement_->end());
    return result.liststatement_;
  }
}

/* Entrypoint: parse ListType* from file. */
ListType* pListType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtype_->begin(), result.listtype_->end());
    return result.listtype_;
  }
}

/* Entrypoint: parse ListType* from string. */
ListType* psListType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtype_->begin(), result.listtype_->end());
    return result.listtype_;
  }
}

/* Entrypoint: parse Type* from file. */
Type* pType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from string. */
Type* psType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse ListRecordTypeField_* from file. */
ListRecordTypeField_* pListRecordTypeField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listrecordtypefield__->begin(), result.listrecordtypefield__->end());
    return result.listrecordtypefield__;
  }
}

/* Entrypoint: parse ListRecordTypeField_* from string. */
ListRecordTypeField_* psListRecordTypeField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listrecordtypefield__->begin(), result.listrecordtypefield__->end());
    return result.listrecordtypefield__;
  }
}

/* Entrypoint: parse RecordTypeField_* from file. */
RecordTypeField_* pRecordTypeField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.recordtypefield__;
  }
}

/* Entrypoint: parse RecordTypeField_* from string. */
RecordTypeField_* psRecordTypeField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.recordtypefield__;
  }
}

/* Entrypoint: parse ListVariantTypeField_* from file. */
ListVariantTypeField_* pListVariantTypeField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listvarianttypefield__->begin(), result.listvarianttypefield__->end());
    return result.listvarianttypefield__;
  }
}

/* Entrypoint: parse ListVariantTypeField_* from string. */
ListVariantTypeField_* psListVariantTypeField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listvarianttypefield__->begin(), result.listvarianttypefield__->end());
    return result.listvarianttypefield__;
  }
}

/* Entrypoint: parse VariantTypeField_* from file. */
VariantTypeField_* pVariantTypeField_(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varianttypefield__;
  }
}

/* Entrypoint: parse VariantTypeField_* from string. */
VariantTypeField_* psVariantTypeField_(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = syntax__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = syntax__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  syntax__delete_buffer(buf, scanner);
  syntax_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.varianttypefield__;
  }
}



