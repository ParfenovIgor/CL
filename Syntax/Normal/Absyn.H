/* File generated by the BNF Converter (bnfc 2.9.4). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;




/********************   Forward Declarations    ********************/

class Program;
class Expr;
class AbstractionField_;
class WhereField_;
class RecordField_;
class VariantField_;
class Statement;
class Type;
class RecordTypeField_;
class VariantTypeField_;
class ProgramRoot;
class Where;
class MultiWhere;
class Abstraction;
class MultiAbstraction;
class Application;
class TypeAbstraction;
class TypeApplication;
class AbstractionField;
class ConstTrue;
class ConstFalse;
class ConstZero;
class If;
class Succ;
class Pred;
class IsZero;
class Var;
class Fix;
class Reference;
class Dereference;
class Tuple;
class TupleGet;
class Record;
class RecordGet;
class Variant;
class VariantCase;
class Array;
class ArrayGet;
class ArrayPush;
class ArrayPop;
class ArrayLen;
class ConstInt;
class ToInt;
class AddInt;
class SubInt;
class MulInt;
class DivInt;
class EquInt;
class LesInt;
class ConstReal;
class ToReal;
class AddReal;
class SubReal;
class MulReal;
class DivReal;
class EquReal;
class LesReal;
class ReadInt;
class ReadReal;
class WriteInt;
class WriteReal;
class WhereField;
class RecordField;
class VariantField;
class Import;
class Definition;
class MoveAssignment;
class CopyAssignment;
class IfStatement;
class IfElseStatement;
class Loop;
class Break;
class Continue;
class Return;
class Eval;
class AutoType;
class BoolType;
class NatType;
class RefType;
class VarType;
class UniType;
class FunType;
class TupleType;
class RecordType;
class VariantType;
class ArrayType;
class IntType;
class RealType;
class RecordTypeField;
class VariantTypeField;
class ListExpr;
class ListAbstractionField_;
class ListWhereField_;
class ListRecordField_;
class ListVariantField_;
class ListStatement;
class ListType;
class ListRecordTypeField_;
class ListVariantTypeField_;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitAbstractionField_(AbstractionField_ *p) = 0;
  virtual void visitWhereField_(WhereField_ *p) = 0;
  virtual void visitRecordField_(RecordField_ *p) = 0;
  virtual void visitVariantField_(VariantField_ *p) = 0;
  virtual void visitStatement(Statement *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitRecordTypeField_(RecordTypeField_ *p) = 0;
  virtual void visitVariantTypeField_(VariantTypeField_ *p) = 0;
  virtual void visitProgramRoot(ProgramRoot *p) = 0;
  virtual void visitWhere(Where *p) = 0;
  virtual void visitMultiWhere(MultiWhere *p) = 0;
  virtual void visitAbstraction(Abstraction *p) = 0;
  virtual void visitMultiAbstraction(MultiAbstraction *p) = 0;
  virtual void visitApplication(Application *p) = 0;
  virtual void visitTypeAbstraction(TypeAbstraction *p) = 0;
  virtual void visitTypeApplication(TypeApplication *p) = 0;
  virtual void visitAbstractionField(AbstractionField *p) = 0;
  virtual void visitConstTrue(ConstTrue *p) = 0;
  virtual void visitConstFalse(ConstFalse *p) = 0;
  virtual void visitConstZero(ConstZero *p) = 0;
  virtual void visitIf(If *p) = 0;
  virtual void visitSucc(Succ *p) = 0;
  virtual void visitPred(Pred *p) = 0;
  virtual void visitIsZero(IsZero *p) = 0;
  virtual void visitVar(Var *p) = 0;
  virtual void visitFix(Fix *p) = 0;
  virtual void visitReference(Reference *p) = 0;
  virtual void visitDereference(Dereference *p) = 0;
  virtual void visitTuple(Tuple *p) = 0;
  virtual void visitTupleGet(TupleGet *p) = 0;
  virtual void visitRecord(Record *p) = 0;
  virtual void visitRecordGet(RecordGet *p) = 0;
  virtual void visitVariant(Variant *p) = 0;
  virtual void visitVariantCase(VariantCase *p) = 0;
  virtual void visitArray(Array *p) = 0;
  virtual void visitArrayGet(ArrayGet *p) = 0;
  virtual void visitArrayPush(ArrayPush *p) = 0;
  virtual void visitArrayPop(ArrayPop *p) = 0;
  virtual void visitArrayLen(ArrayLen *p) = 0;
  virtual void visitConstInt(ConstInt *p) = 0;
  virtual void visitToInt(ToInt *p) = 0;
  virtual void visitAddInt(AddInt *p) = 0;
  virtual void visitSubInt(SubInt *p) = 0;
  virtual void visitMulInt(MulInt *p) = 0;
  virtual void visitDivInt(DivInt *p) = 0;
  virtual void visitEquInt(EquInt *p) = 0;
  virtual void visitLesInt(LesInt *p) = 0;
  virtual void visitConstReal(ConstReal *p) = 0;
  virtual void visitToReal(ToReal *p) = 0;
  virtual void visitAddReal(AddReal *p) = 0;
  virtual void visitSubReal(SubReal *p) = 0;
  virtual void visitMulReal(MulReal *p) = 0;
  virtual void visitDivReal(DivReal *p) = 0;
  virtual void visitEquReal(EquReal *p) = 0;
  virtual void visitLesReal(LesReal *p) = 0;
  virtual void visitReadInt(ReadInt *p) = 0;
  virtual void visitReadReal(ReadReal *p) = 0;
  virtual void visitWriteInt(WriteInt *p) = 0;
  virtual void visitWriteReal(WriteReal *p) = 0;
  virtual void visitWhereField(WhereField *p) = 0;
  virtual void visitRecordField(RecordField *p) = 0;
  virtual void visitVariantField(VariantField *p) = 0;
  virtual void visitImport(Import *p) = 0;
  virtual void visitDefinition(Definition *p) = 0;
  virtual void visitMoveAssignment(MoveAssignment *p) = 0;
  virtual void visitCopyAssignment(CopyAssignment *p) = 0;
  virtual void visitIfStatement(IfStatement *p) = 0;
  virtual void visitIfElseStatement(IfElseStatement *p) = 0;
  virtual void visitLoop(Loop *p) = 0;
  virtual void visitBreak(Break *p) = 0;
  virtual void visitContinue(Continue *p) = 0;
  virtual void visitReturn(Return *p) = 0;
  virtual void visitEval(Eval *p) = 0;
  virtual void visitAutoType(AutoType *p) = 0;
  virtual void visitBoolType(BoolType *p) = 0;
  virtual void visitNatType(NatType *p) = 0;
  virtual void visitRefType(RefType *p) = 0;
  virtual void visitVarType(VarType *p) = 0;
  virtual void visitUniType(UniType *p) = 0;
  virtual void visitFunType(FunType *p) = 0;
  virtual void visitTupleType(TupleType *p) = 0;
  virtual void visitRecordType(RecordType *p) = 0;
  virtual void visitVariantType(VariantType *p) = 0;
  virtual void visitArrayType(ArrayType *p) = 0;
  virtual void visitIntType(IntType *p) = 0;
  virtual void visitRealType(RealType *p) = 0;
  virtual void visitRecordTypeField(RecordTypeField *p) = 0;
  virtual void visitVariantTypeField(VariantTypeField *p) = 0;
  virtual void visitListExpr(ListExpr *p) = 0;
  virtual void visitListAbstractionField_(ListAbstractionField_ *p) = 0;
  virtual void visitListWhereField_(ListWhereField_ *p) = 0;
  virtual void visitListRecordField_(ListRecordField_ *p) = 0;
  virtual void visitListVariantField_(ListVariantField_ *p) = 0;
  virtual void visitListStatement(ListStatement *p) = 0;
  virtual void visitListType(ListType *p) = 0;
  virtual void visitListRecordTypeField_(ListRecordTypeField_ *p) = 0;
  virtual void visitListVariantTypeField_(ListVariantTypeField_ *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;

};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;

};

class AbstractionField_ : public Visitable
{
public:
  virtual AbstractionField_ *clone() const = 0;

};

class WhereField_ : public Visitable
{
public:
  virtual WhereField_ *clone() const = 0;

};

class RecordField_ : public Visitable
{
public:
  virtual RecordField_ *clone() const = 0;

};

class VariantField_ : public Visitable
{
public:
  virtual VariantField_ *clone() const = 0;

};

class Statement : public Visitable
{
public:
  virtual Statement *clone() const = 0;

};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;

};

class RecordTypeField_ : public Visitable
{
public:
  virtual RecordTypeField_ *clone() const = 0;

};

class VariantTypeField_ : public Visitable
{
public:
  virtual VariantTypeField_ *clone() const = 0;

};



class ProgramRoot : public Program
{
public:
  ListStatement *liststatement_;

  ProgramRoot(const ProgramRoot &);
  ProgramRoot &operator=(const ProgramRoot &);
  ProgramRoot(ListStatement *p1);
  ~ProgramRoot();
  virtual void accept(Visitor *v);
  virtual ProgramRoot *clone() const;
  void swap(ProgramRoot &);
};

class Where : public Expr
{
public:
  Expr *expr_1;
  Type *type_;
  Ident ident_;
  Expr *expr_2;

  Where(const Where &);
  Where &operator=(const Where &);
  Where(Expr *p1, Type *p2, Ident p3, Expr *p4);
  ~Where();
  virtual void accept(Visitor *v);
  virtual Where *clone() const;
  void swap(Where &);
};

class MultiWhere : public Expr
{
public:
  Expr *expr_;
  ListWhereField_ *listwherefield__;

  MultiWhere(const MultiWhere &);
  MultiWhere &operator=(const MultiWhere &);
  MultiWhere(Expr *p1, ListWhereField_ *p2);
  ~MultiWhere();
  virtual void accept(Visitor *v);
  virtual MultiWhere *clone() const;
  void swap(MultiWhere &);
};

class Abstraction : public Expr
{
public:
  Type *type_;
  Ident ident_;
  ListStatement *liststatement_;
  Expr *expr_;

  Abstraction(const Abstraction &);
  Abstraction &operator=(const Abstraction &);
  Abstraction(Type *p1, Ident p2, ListStatement *p3, Expr *p4);
  ~Abstraction();
  virtual void accept(Visitor *v);
  virtual Abstraction *clone() const;
  void swap(Abstraction &);
};

class MultiAbstraction : public Expr
{
public:
  ListAbstractionField_ *listabstractionfield__;
  ListStatement *liststatement_;
  Expr *expr_;

  MultiAbstraction(const MultiAbstraction &);
  MultiAbstraction &operator=(const MultiAbstraction &);
  MultiAbstraction(ListAbstractionField_ *p1, ListStatement *p2, Expr *p3);
  ~MultiAbstraction();
  virtual void accept(Visitor *v);
  virtual MultiAbstraction *clone() const;
  void swap(MultiAbstraction &);
};

class Application : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Application(const Application &);
  Application &operator=(const Application &);
  Application(Expr *p1, Expr *p2);
  ~Application();
  virtual void accept(Visitor *v);
  virtual Application *clone() const;
  void swap(Application &);
};

class TypeAbstraction : public Expr
{
public:
  Ident ident_;
  Expr *expr_;

  TypeAbstraction(const TypeAbstraction &);
  TypeAbstraction &operator=(const TypeAbstraction &);
  TypeAbstraction(Ident p1, Expr *p2);
  ~TypeAbstraction();
  virtual void accept(Visitor *v);
  virtual TypeAbstraction *clone() const;
  void swap(TypeAbstraction &);
};

class TypeApplication : public Expr
{
public:
  Expr *expr_;
  Type *type_;

  TypeApplication(const TypeApplication &);
  TypeApplication &operator=(const TypeApplication &);
  TypeApplication(Expr *p1, Type *p2);
  ~TypeApplication();
  virtual void accept(Visitor *v);
  virtual TypeApplication *clone() const;
  void swap(TypeApplication &);
};

class ConstTrue : public Expr
{
public:

  ConstTrue(const ConstTrue &);
  ConstTrue &operator=(const ConstTrue &);
  ConstTrue();
  ~ConstTrue();
  virtual void accept(Visitor *v);
  virtual ConstTrue *clone() const;
  void swap(ConstTrue &);
};

class ConstFalse : public Expr
{
public:

  ConstFalse(const ConstFalse &);
  ConstFalse &operator=(const ConstFalse &);
  ConstFalse();
  ~ConstFalse();
  virtual void accept(Visitor *v);
  virtual ConstFalse *clone() const;
  void swap(ConstFalse &);
};

class ConstZero : public Expr
{
public:

  ConstZero(const ConstZero &);
  ConstZero &operator=(const ConstZero &);
  ConstZero();
  ~ConstZero();
  virtual void accept(Visitor *v);
  virtual ConstZero *clone() const;
  void swap(ConstZero &);
};

class If : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;
  Expr *expr_3;

  If(const If &);
  If &operator=(const If &);
  If(Expr *p1, Expr *p2, Expr *p3);
  ~If();
  virtual void accept(Visitor *v);
  virtual If *clone() const;
  void swap(If &);
};

class Succ : public Expr
{
public:
  Expr *expr_;

  Succ(const Succ &);
  Succ &operator=(const Succ &);
  Succ(Expr *p1);
  ~Succ();
  virtual void accept(Visitor *v);
  virtual Succ *clone() const;
  void swap(Succ &);
};

class Pred : public Expr
{
public:
  Expr *expr_;

  Pred(const Pred &);
  Pred &operator=(const Pred &);
  Pred(Expr *p1);
  ~Pred();
  virtual void accept(Visitor *v);
  virtual Pred *clone() const;
  void swap(Pred &);
};

class IsZero : public Expr
{
public:
  Expr *expr_;

  IsZero(const IsZero &);
  IsZero &operator=(const IsZero &);
  IsZero(Expr *p1);
  ~IsZero();
  virtual void accept(Visitor *v);
  virtual IsZero *clone() const;
  void swap(IsZero &);
};

class Var : public Expr
{
public:
  Ident ident_;

  Var(const Var &);
  Var &operator=(const Var &);
  Var(Ident p1);
  ~Var();
  virtual void accept(Visitor *v);
  virtual Var *clone() const;
  void swap(Var &);
};

class Fix : public Expr
{
public:
  Expr *expr_;

  Fix(const Fix &);
  Fix &operator=(const Fix &);
  Fix(Expr *p1);
  ~Fix();
  virtual void accept(Visitor *v);
  virtual Fix *clone() const;
  void swap(Fix &);
};

class Reference : public Expr
{
public:
  Expr *expr_;

  Reference(const Reference &);
  Reference &operator=(const Reference &);
  Reference(Expr *p1);
  ~Reference();
  virtual void accept(Visitor *v);
  virtual Reference *clone() const;
  void swap(Reference &);
};

class Dereference : public Expr
{
public:
  Expr *expr_;

  Dereference(const Dereference &);
  Dereference &operator=(const Dereference &);
  Dereference(Expr *p1);
  ~Dereference();
  virtual void accept(Visitor *v);
  virtual Dereference *clone() const;
  void swap(Dereference &);
};

class Tuple : public Expr
{
public:
  ListExpr *listexpr_;

  Tuple(const Tuple &);
  Tuple &operator=(const Tuple &);
  Tuple(ListExpr *p1);
  ~Tuple();
  virtual void accept(Visitor *v);
  virtual Tuple *clone() const;
  void swap(Tuple &);
};

class TupleGet : public Expr
{
public:
  Expr *expr_;
  Integer integer_;

  TupleGet(const TupleGet &);
  TupleGet &operator=(const TupleGet &);
  TupleGet(Expr *p1, Integer p2);
  ~TupleGet();
  virtual void accept(Visitor *v);
  virtual TupleGet *clone() const;
  void swap(TupleGet &);
};

class Record : public Expr
{
public:
  ListRecordField_ *listrecordfield__;

  Record(const Record &);
  Record &operator=(const Record &);
  Record(ListRecordField_ *p1);
  ~Record();
  virtual void accept(Visitor *v);
  virtual Record *clone() const;
  void swap(Record &);
};

class RecordGet : public Expr
{
public:
  Expr *expr_;
  Ident ident_;

  RecordGet(const RecordGet &);
  RecordGet &operator=(const RecordGet &);
  RecordGet(Expr *p1, Ident p2);
  ~RecordGet();
  virtual void accept(Visitor *v);
  virtual RecordGet *clone() const;
  void swap(RecordGet &);
};

class Variant : public Expr
{
public:
  Ident ident_;
  Expr *expr_;
  Type *type_;

  Variant(const Variant &);
  Variant &operator=(const Variant &);
  Variant(Ident p1, Expr *p2, Type *p3);
  ~Variant();
  virtual void accept(Visitor *v);
  virtual Variant *clone() const;
  void swap(Variant &);
};

class VariantCase : public Expr
{
public:
  Expr *expr_;
  ListVariantField_ *listvariantfield__;

  VariantCase(const VariantCase &);
  VariantCase &operator=(const VariantCase &);
  VariantCase(Expr *p1, ListVariantField_ *p2);
  ~VariantCase();
  virtual void accept(Visitor *v);
  virtual VariantCase *clone() const;
  void swap(VariantCase &);
};

class Array : public Expr
{
public:
  ListExpr *listexpr_;

  Array(const Array &);
  Array &operator=(const Array &);
  Array(ListExpr *p1);
  ~Array();
  virtual void accept(Visitor *v);
  virtual Array *clone() const;
  void swap(Array &);
};

class ArrayGet : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  ArrayGet(const ArrayGet &);
  ArrayGet &operator=(const ArrayGet &);
  ArrayGet(Expr *p1, Expr *p2);
  ~ArrayGet();
  virtual void accept(Visitor *v);
  virtual ArrayGet *clone() const;
  void swap(ArrayGet &);
};

class ArrayPush : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  ArrayPush(const ArrayPush &);
  ArrayPush &operator=(const ArrayPush &);
  ArrayPush(Expr *p1, Expr *p2);
  ~ArrayPush();
  virtual void accept(Visitor *v);
  virtual ArrayPush *clone() const;
  void swap(ArrayPush &);
};

class ArrayPop : public Expr
{
public:
  Expr *expr_;

  ArrayPop(const ArrayPop &);
  ArrayPop &operator=(const ArrayPop &);
  ArrayPop(Expr *p1);
  ~ArrayPop();
  virtual void accept(Visitor *v);
  virtual ArrayPop *clone() const;
  void swap(ArrayPop &);
};

class ArrayLen : public Expr
{
public:
  Expr *expr_;

  ArrayLen(const ArrayLen &);
  ArrayLen &operator=(const ArrayLen &);
  ArrayLen(Expr *p1);
  ~ArrayLen();
  virtual void accept(Visitor *v);
  virtual ArrayLen *clone() const;
  void swap(ArrayLen &);
};

class ConstInt : public Expr
{
public:
  Integer integer_;

  ConstInt(const ConstInt &);
  ConstInt &operator=(const ConstInt &);
  ConstInt(Integer p1);
  ~ConstInt();
  virtual void accept(Visitor *v);
  virtual ConstInt *clone() const;
  void swap(ConstInt &);
};

class ToInt : public Expr
{
public:
  Expr *expr_;

  ToInt(const ToInt &);
  ToInt &operator=(const ToInt &);
  ToInt(Expr *p1);
  ~ToInt();
  virtual void accept(Visitor *v);
  virtual ToInt *clone() const;
  void swap(ToInt &);
};

class AddInt : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  AddInt(const AddInt &);
  AddInt &operator=(const AddInt &);
  AddInt(Expr *p1, Expr *p2);
  ~AddInt();
  virtual void accept(Visitor *v);
  virtual AddInt *clone() const;
  void swap(AddInt &);
};

class SubInt : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  SubInt(const SubInt &);
  SubInt &operator=(const SubInt &);
  SubInt(Expr *p1, Expr *p2);
  ~SubInt();
  virtual void accept(Visitor *v);
  virtual SubInt *clone() const;
  void swap(SubInt &);
};

class MulInt : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  MulInt(const MulInt &);
  MulInt &operator=(const MulInt &);
  MulInt(Expr *p1, Expr *p2);
  ~MulInt();
  virtual void accept(Visitor *v);
  virtual MulInt *clone() const;
  void swap(MulInt &);
};

class DivInt : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  DivInt(const DivInt &);
  DivInt &operator=(const DivInt &);
  DivInt(Expr *p1, Expr *p2);
  ~DivInt();
  virtual void accept(Visitor *v);
  virtual DivInt *clone() const;
  void swap(DivInt &);
};

class EquInt : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EquInt(const EquInt &);
  EquInt &operator=(const EquInt &);
  EquInt(Expr *p1, Expr *p2);
  ~EquInt();
  virtual void accept(Visitor *v);
  virtual EquInt *clone() const;
  void swap(EquInt &);
};

class LesInt : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LesInt(const LesInt &);
  LesInt &operator=(const LesInt &);
  LesInt(Expr *p1, Expr *p2);
  ~LesInt();
  virtual void accept(Visitor *v);
  virtual LesInt *clone() const;
  void swap(LesInt &);
};

class ConstReal : public Expr
{
public:
  Double double_;

  ConstReal(const ConstReal &);
  ConstReal &operator=(const ConstReal &);
  ConstReal(Double p1);
  ~ConstReal();
  virtual void accept(Visitor *v);
  virtual ConstReal *clone() const;
  void swap(ConstReal &);
};

class ToReal : public Expr
{
public:
  Expr *expr_;

  ToReal(const ToReal &);
  ToReal &operator=(const ToReal &);
  ToReal(Expr *p1);
  ~ToReal();
  virtual void accept(Visitor *v);
  virtual ToReal *clone() const;
  void swap(ToReal &);
};

class AddReal : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  AddReal(const AddReal &);
  AddReal &operator=(const AddReal &);
  AddReal(Expr *p1, Expr *p2);
  ~AddReal();
  virtual void accept(Visitor *v);
  virtual AddReal *clone() const;
  void swap(AddReal &);
};

class SubReal : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  SubReal(const SubReal &);
  SubReal &operator=(const SubReal &);
  SubReal(Expr *p1, Expr *p2);
  ~SubReal();
  virtual void accept(Visitor *v);
  virtual SubReal *clone() const;
  void swap(SubReal &);
};

class MulReal : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  MulReal(const MulReal &);
  MulReal &operator=(const MulReal &);
  MulReal(Expr *p1, Expr *p2);
  ~MulReal();
  virtual void accept(Visitor *v);
  virtual MulReal *clone() const;
  void swap(MulReal &);
};

class DivReal : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  DivReal(const DivReal &);
  DivReal &operator=(const DivReal &);
  DivReal(Expr *p1, Expr *p2);
  ~DivReal();
  virtual void accept(Visitor *v);
  virtual DivReal *clone() const;
  void swap(DivReal &);
};

class EquReal : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  EquReal(const EquReal &);
  EquReal &operator=(const EquReal &);
  EquReal(Expr *p1, Expr *p2);
  ~EquReal();
  virtual void accept(Visitor *v);
  virtual EquReal *clone() const;
  void swap(EquReal &);
};

class LesReal : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LesReal(const LesReal &);
  LesReal &operator=(const LesReal &);
  LesReal(Expr *p1, Expr *p2);
  ~LesReal();
  virtual void accept(Visitor *v);
  virtual LesReal *clone() const;
  void swap(LesReal &);
};

class ReadInt : public Expr
{
public:

  ReadInt(const ReadInt &);
  ReadInt &operator=(const ReadInt &);
  ReadInt();
  ~ReadInt();
  virtual void accept(Visitor *v);
  virtual ReadInt *clone() const;
  void swap(ReadInt &);
};

class ReadReal : public Expr
{
public:

  ReadReal(const ReadReal &);
  ReadReal &operator=(const ReadReal &);
  ReadReal();
  ~ReadReal();
  virtual void accept(Visitor *v);
  virtual ReadReal *clone() const;
  void swap(ReadReal &);
};

class WriteInt : public Expr
{
public:
  Expr *expr_;

  WriteInt(const WriteInt &);
  WriteInt &operator=(const WriteInt &);
  WriteInt(Expr *p1);
  ~WriteInt();
  virtual void accept(Visitor *v);
  virtual WriteInt *clone() const;
  void swap(WriteInt &);
};

class WriteReal : public Expr
{
public:
  Expr *expr_;

  WriteReal(const WriteReal &);
  WriteReal &operator=(const WriteReal &);
  WriteReal(Expr *p1);
  ~WriteReal();
  virtual void accept(Visitor *v);
  virtual WriteReal *clone() const;
  void swap(WriteReal &);
};

class AbstractionField : public AbstractionField_
{
public:
  Type *type_;
  Ident ident_;

  AbstractionField(const AbstractionField &);
  AbstractionField &operator=(const AbstractionField &);
  AbstractionField(Type *p1, Ident p2);
  ~AbstractionField();
  virtual void accept(Visitor *v);
  virtual AbstractionField *clone() const;
  void swap(AbstractionField &);
};

class WhereField : public WhereField_
{
public:
  Ident ident_;
  Type *type_;
  Expr *expr_;

  WhereField(const WhereField &);
  WhereField &operator=(const WhereField &);
  WhereField(Ident p1, Type *p2, Expr *p3);
  ~WhereField();
  virtual void accept(Visitor *v);
  virtual WhereField *clone() const;
  void swap(WhereField &);
};

class RecordField : public RecordField_
{
public:
  Ident ident_;
  Expr *expr_;

  RecordField(const RecordField &);
  RecordField &operator=(const RecordField &);
  RecordField(Ident p1, Expr *p2);
  ~RecordField();
  virtual void accept(Visitor *v);
  virtual RecordField *clone() const;
  void swap(RecordField &);
};

class VariantField : public VariantField_
{
public:
  Ident ident_1;
  Ident ident_2;
  Expr *expr_;

  VariantField(const VariantField &);
  VariantField &operator=(const VariantField &);
  VariantField(Ident p1, Ident p2, Expr *p3);
  ~VariantField();
  virtual void accept(Visitor *v);
  virtual VariantField *clone() const;
  void swap(VariantField &);
};

class Import : public Statement
{
public:
  Ident ident_;

  Import(const Import &);
  Import &operator=(const Import &);
  Import(Ident p1);
  ~Import();
  virtual void accept(Visitor *v);
  virtual Import *clone() const;
  void swap(Import &);
};

class Definition : public Statement
{
public:
  Type *type_;
  Ident ident_;
  Expr *expr_;

  Definition(const Definition &);
  Definition &operator=(const Definition &);
  Definition(Type *p1, Ident p2, Expr *p3);
  ~Definition();
  virtual void accept(Visitor *v);
  virtual Definition *clone() const;
  void swap(Definition &);
};

class MoveAssignment : public Statement
{
public:
  Expr *expr_1;
  Expr *expr_2;

  MoveAssignment(const MoveAssignment &);
  MoveAssignment &operator=(const MoveAssignment &);
  MoveAssignment(Expr *p1, Expr *p2);
  ~MoveAssignment();
  virtual void accept(Visitor *v);
  virtual MoveAssignment *clone() const;
  void swap(MoveAssignment &);
};

class CopyAssignment : public Statement
{
public:
  Expr *expr_1;
  Expr *expr_2;

  CopyAssignment(const CopyAssignment &);
  CopyAssignment &operator=(const CopyAssignment &);
  CopyAssignment(Expr *p1, Expr *p2);
  ~CopyAssignment();
  virtual void accept(Visitor *v);
  virtual CopyAssignment *clone() const;
  void swap(CopyAssignment &);
};

class IfStatement : public Statement
{
public:
  Expr *expr_;
  ListStatement *liststatement_;

  IfStatement(const IfStatement &);
  IfStatement &operator=(const IfStatement &);
  IfStatement(Expr *p1, ListStatement *p2);
  ~IfStatement();
  virtual void accept(Visitor *v);
  virtual IfStatement *clone() const;
  void swap(IfStatement &);
};

class IfElseStatement : public Statement
{
public:
  Expr *expr_;
  ListStatement *liststatement_1;
  ListStatement *liststatement_2;

  IfElseStatement(const IfElseStatement &);
  IfElseStatement &operator=(const IfElseStatement &);
  IfElseStatement(Expr *p1, ListStatement *p2, ListStatement *p3);
  ~IfElseStatement();
  virtual void accept(Visitor *v);
  virtual IfElseStatement *clone() const;
  void swap(IfElseStatement &);
};

class Loop : public Statement
{
public:
  ListStatement *liststatement_;

  Loop(const Loop &);
  Loop &operator=(const Loop &);
  Loop(ListStatement *p1);
  ~Loop();
  virtual void accept(Visitor *v);
  virtual Loop *clone() const;
  void swap(Loop &);
};

class Break : public Statement
{
public:

  Break(const Break &);
  Break &operator=(const Break &);
  Break();
  ~Break();
  virtual void accept(Visitor *v);
  virtual Break *clone() const;
  void swap(Break &);
};

class Continue : public Statement
{
public:

  Continue(const Continue &);
  Continue &operator=(const Continue &);
  Continue();
  ~Continue();
  virtual void accept(Visitor *v);
  virtual Continue *clone() const;
  void swap(Continue &);
};

class Return : public Statement
{
public:

  Return(const Return &);
  Return &operator=(const Return &);
  Return();
  ~Return();
  virtual void accept(Visitor *v);
  virtual Return *clone() const;
  void swap(Return &);
};

class Eval : public Statement
{
public:
  Expr *expr_;

  Eval(const Eval &);
  Eval &operator=(const Eval &);
  Eval(Expr *p1);
  ~Eval();
  virtual void accept(Visitor *v);
  virtual Eval *clone() const;
  void swap(Eval &);
};

class AutoType : public Type
{
public:

  AutoType(const AutoType &);
  AutoType &operator=(const AutoType &);
  AutoType();
  ~AutoType();
  virtual void accept(Visitor *v);
  virtual AutoType *clone() const;
  void swap(AutoType &);
};

class BoolType : public Type
{
public:

  BoolType(const BoolType &);
  BoolType &operator=(const BoolType &);
  BoolType();
  ~BoolType();
  virtual void accept(Visitor *v);
  virtual BoolType *clone() const;
  void swap(BoolType &);
};

class NatType : public Type
{
public:

  NatType(const NatType &);
  NatType &operator=(const NatType &);
  NatType();
  ~NatType();
  virtual void accept(Visitor *v);
  virtual NatType *clone() const;
  void swap(NatType &);
};

class RefType : public Type
{
public:
  Type *type_;

  RefType(const RefType &);
  RefType &operator=(const RefType &);
  RefType(Type *p1);
  ~RefType();
  virtual void accept(Visitor *v);
  virtual RefType *clone() const;
  void swap(RefType &);
};

class VarType : public Type
{
public:
  Ident ident_;

  VarType(const VarType &);
  VarType &operator=(const VarType &);
  VarType(Ident p1);
  ~VarType();
  virtual void accept(Visitor *v);
  virtual VarType *clone() const;
  void swap(VarType &);
};

class UniType : public Type
{
public:
  Ident ident_;
  Type *type_;

  UniType(const UniType &);
  UniType &operator=(const UniType &);
  UniType(Ident p1, Type *p2);
  ~UniType();
  virtual void accept(Visitor *v);
  virtual UniType *clone() const;
  void swap(UniType &);
};

class FunType : public Type
{
public:
  Type *type_1;
  Type *type_2;

  FunType(const FunType &);
  FunType &operator=(const FunType &);
  FunType(Type *p1, Type *p2);
  ~FunType();
  virtual void accept(Visitor *v);
  virtual FunType *clone() const;
  void swap(FunType &);
};

class TupleType : public Type
{
public:
  ListType *listtype_;

  TupleType(const TupleType &);
  TupleType &operator=(const TupleType &);
  TupleType(ListType *p1);
  ~TupleType();
  virtual void accept(Visitor *v);
  virtual TupleType *clone() const;
  void swap(TupleType &);
};

class RecordType : public Type
{
public:
  ListRecordTypeField_ *listrecordtypefield__;

  RecordType(const RecordType &);
  RecordType &operator=(const RecordType &);
  RecordType(ListRecordTypeField_ *p1);
  ~RecordType();
  virtual void accept(Visitor *v);
  virtual RecordType *clone() const;
  void swap(RecordType &);
};

class VariantType : public Type
{
public:
  ListVariantTypeField_ *listvarianttypefield__;

  VariantType(const VariantType &);
  VariantType &operator=(const VariantType &);
  VariantType(ListVariantTypeField_ *p1);
  ~VariantType();
  virtual void accept(Visitor *v);
  virtual VariantType *clone() const;
  void swap(VariantType &);
};

class ArrayType : public Type
{
public:
  Type *type_;

  ArrayType(const ArrayType &);
  ArrayType &operator=(const ArrayType &);
  ArrayType(Type *p1);
  ~ArrayType();
  virtual void accept(Visitor *v);
  virtual ArrayType *clone() const;
  void swap(ArrayType &);
};

class IntType : public Type
{
public:

  IntType(const IntType &);
  IntType &operator=(const IntType &);
  IntType();
  ~IntType();
  virtual void accept(Visitor *v);
  virtual IntType *clone() const;
  void swap(IntType &);
};

class RealType : public Type
{
public:

  RealType(const RealType &);
  RealType &operator=(const RealType &);
  RealType();
  ~RealType();
  virtual void accept(Visitor *v);
  virtual RealType *clone() const;
  void swap(RealType &);
};

class RecordTypeField : public RecordTypeField_
{
public:
  Ident ident_;
  Type *type_;

  RecordTypeField(const RecordTypeField &);
  RecordTypeField &operator=(const RecordTypeField &);
  RecordTypeField(Ident p1, Type *p2);
  ~RecordTypeField();
  virtual void accept(Visitor *v);
  virtual RecordTypeField *clone() const;
  void swap(RecordTypeField &);
};

class VariantTypeField : public VariantTypeField_
{
public:
  Ident ident_;
  Type *type_;

  VariantTypeField(const VariantTypeField &);
  VariantTypeField &operator=(const VariantTypeField &);
  VariantTypeField(Ident p1, Type *p2);
  ~VariantTypeField();
  virtual void accept(Visitor *v);
  virtual VariantTypeField *clone() const;
  void swap(VariantTypeField &);
};



class ListExpr : public Visitable, public std::vector<Expr*>
{
public:
  ListExpr();
  ListExpr(const ListExpr &);
  virtual void accept(Visitor *v);
  virtual ListExpr *clone() const;
};

ListExpr* consListExpr(Expr* x, ListExpr* xs);

class ListAbstractionField_ : public Visitable, public std::vector<AbstractionField_*>
{
public:
  ListAbstractionField_();
  ListAbstractionField_(const ListAbstractionField_ &);
  virtual void accept(Visitor *v);
  virtual ListAbstractionField_ *clone() const;
};

ListAbstractionField_* consListAbstractionField_(AbstractionField_* x, ListAbstractionField_* xs);

class ListWhereField_ : public Visitable, public std::vector<WhereField_*>
{
public:
  ListWhereField_();
  ListWhereField_(const ListWhereField_ &);
  virtual void accept(Visitor *v);
  virtual ListWhereField_ *clone() const;
};

ListWhereField_* consListWhereField_(WhereField_* x, ListWhereField_* xs);

class ListRecordField_ : public Visitable, public std::vector<RecordField_*>
{
public:
  ListRecordField_();
  ListRecordField_(const ListRecordField_ &);
  virtual void accept(Visitor *v);
  virtual ListRecordField_ *clone() const;
};

ListRecordField_* consListRecordField_(RecordField_* x, ListRecordField_* xs);

class ListVariantField_ : public Visitable, public std::vector<VariantField_*>
{
public:
  ListVariantField_();
  ListVariantField_(const ListVariantField_ &);
  virtual void accept(Visitor *v);
  virtual ListVariantField_ *clone() const;
};

ListVariantField_* consListVariantField_(VariantField_* x, ListVariantField_* xs);

class ListStatement : public Visitable, public std::vector<Statement*>
{
public:
  ListStatement();
  ListStatement(const ListStatement &);
  virtual void accept(Visitor *v);
  virtual ListStatement *clone() const;
};

ListStatement* consListStatement(Statement* x, ListStatement* xs);

class ListType : public Visitable, public std::vector<Type*>
{
public:
  ListType();
  ListType(const ListType &);
  virtual void accept(Visitor *v);
  virtual ListType *clone() const;
};

ListType* consListType(Type* x, ListType* xs);

class ListRecordTypeField_ : public Visitable, public std::vector<RecordTypeField_*>
{
public:
  ListRecordTypeField_();
  ListRecordTypeField_(const ListRecordTypeField_ &);
  virtual void accept(Visitor *v);
  virtual ListRecordTypeField_ *clone() const;
};

ListRecordTypeField_* consListRecordTypeField_(RecordTypeField_* x, ListRecordTypeField_* xs);

class ListVariantTypeField_ : public Visitable, public std::vector<VariantTypeField_*>
{
public:
  ListVariantTypeField_();
  ListVariantTypeField_(const ListVariantTypeField_ &);
  virtual void accept(Visitor *v);
  virtual ListVariantTypeField_ *clone() const;
};

ListVariantTypeField_* consListVariantTypeField_(VariantTypeField_* x, ListVariantTypeField_* xs);





#endif
